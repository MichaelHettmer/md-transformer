diff --git a/node_modules/@changesets/cli/changelog/dist/cli.cjs.dev.js b/node_modules/@changesets/cli/changelog/dist/cli.cjs.dev.js
index 2553cbf..5dfaf7e 100644
--- a/node_modules/@changesets/cli/changelog/dist/cli.cjs.dev.js
+++ b/node_modules/@changesets/cli/changelog/dist/cli.cjs.dev.js
@@ -12,7 +12,5 @@ var changelogGit__default = /*#__PURE__*/_interopDefault(changelogGit);
 
 Object.defineProperty(exports, 'default', {
 	enumerable: true,
-	get: function () {
-		return changelogGit__default['default'];
-	}
+	get: function () { return changelogGit__default["default"]; }
 });
diff --git a/node_modules/@changesets/cli/commit/dist/cli.cjs.dev.js b/node_modules/@changesets/cli/commit/dist/cli.cjs.dev.js
index 2dca463..143e09d 100644
--- a/node_modules/@changesets/cli/commit/dist/cli.cjs.dev.js
+++ b/node_modules/@changesets/cli/commit/dist/cli.cjs.dev.js
@@ -10,7 +10,7 @@ var outdent__default = /*#__PURE__*/_interopDefault(outdent);
 
 const getAddMessage = async (changeset, options) => {
   const skipCI = (options === null || options === void 0 ? void 0 : options.skipCI) === "add" || (options === null || options === void 0 ? void 0 : options.skipCI) === true;
-  return outdent__default['default']`docs(changeset): ${changeset.summary}${skipCI ? `\n\n[skip ci]\n` : ""}`;
+  return outdent__default["default"]`docs(changeset): ${changeset.summary}${skipCI ? `\n\n[skip ci]\n` : ""}`;
 };
 
 const getVersionMessage = async (releasePlan, options) => {
@@ -18,7 +18,7 @@ const getVersionMessage = async (releasePlan, options) => {
   const publishableReleases = releasePlan.releases.filter(release => release.type !== "none");
   const numPackagesReleased = publishableReleases.length;
   const releasesLines = publishableReleases.map(release => `  ${release.name}@${release.newVersion}`).join("\n");
-  return outdent__default['default']`
+  return outdent__default["default"]`
     RELEASING: Releasing ${numPackagesReleased} package(s)
 
     Releases:
@@ -32,4 +32,4 @@ const defaultCommitFunctions = {
   getVersionMessage
 };
 
-exports.default = defaultCommitFunctions;
+exports["default"] = defaultCommitFunctions;
diff --git a/node_modules/@changesets/cli/commit/dist/cli.esm.js b/node_modules/@changesets/cli/commit/dist/cli.esm.js
index cc9c814..0c9dde2 100644
--- a/node_modules/@changesets/cli/commit/dist/cli.esm.js
+++ b/node_modules/@changesets/cli/commit/dist/cli.esm.js
@@ -24,4 +24,4 @@ const defaultCommitFunctions = {
   getVersionMessage
 };
 
-export default defaultCommitFunctions;
+export { defaultCommitFunctions as default };
diff --git a/node_modules/@changesets/cli/dist/cli.cjs.dev.js b/node_modules/@changesets/cli/dist/cli.cjs.dev.js
index 5511d0c..a7c1ae4 100644
--- a/node_modules/@changesets/cli/dist/cli.cjs.dev.js
+++ b/node_modules/@changesets/cli/dist/cli.cjs.dev.js
@@ -16,6 +16,7 @@ var enquirer = require('enquirer');
 var externalEditor = require('external-editor');
 var ansiColors = require('ansi-colors');
 var git = require('@changesets/git');
+var types = require('@changesets/types');
 var writeChangeset = require('@changesets/write');
 var resolveFrom = require('resolve-from');
 var semver = require('semver');
@@ -33,11 +34,31 @@ var getReleasePlan = require('@changesets/get-release-plan');
 
 function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }
 
+function _interopNamespace(e) {
+  if (e && e.__esModule) return e;
+  var n = Object.create(null);
+  if (e) {
+    Object.keys(e).forEach(function (k) {
+      if (k !== 'default') {
+        var d = Object.getOwnPropertyDescriptor(e, k);
+        Object.defineProperty(n, k, d.get ? d : {
+          enumerable: true,
+          get: function () { return e[k]; }
+        });
+      }
+    });
+  }
+  n["default"] = e;
+  return Object.freeze(n);
+}
+
 var meow__default = /*#__PURE__*/_interopDefault(meow);
+var logger__namespace = /*#__PURE__*/_interopNamespace(logger);
 var fs__default = /*#__PURE__*/_interopDefault(fs);
 var path__default = /*#__PURE__*/_interopDefault(path);
 var chalk__default = /*#__PURE__*/_interopDefault(chalk);
 var termSize__default = /*#__PURE__*/_interopDefault(termSize);
+var git__namespace = /*#__PURE__*/_interopNamespace(git);
 var writeChangeset__default = /*#__PURE__*/_interopDefault(writeChangeset);
 var resolveFrom__default = /*#__PURE__*/_interopDefault(resolveFrom);
 var semver__default = /*#__PURE__*/_interopDefault(semver);
@@ -72,10 +93,9 @@ function ownKeys(object, enumerableOnly) {
 
   if (Object.getOwnPropertySymbols) {
     var symbols = Object.getOwnPropertySymbols(object);
-    if (enumerableOnly) symbols = symbols.filter(function (sym) {
+    enumerableOnly && (symbols = symbols.filter(function (sym) {
       return Object.getOwnPropertyDescriptor(object, sym).enumerable;
-    });
-    keys.push.apply(keys, symbols);
+    })), keys.push.apply(keys, symbols);
   }
 
   return keys;
@@ -83,36 +103,29 @@ function ownKeys(object, enumerableOnly) {
 
 function _objectSpread2(target) {
   for (var i = 1; i < arguments.length; i++) {
-    var source = arguments[i] != null ? arguments[i] : {};
-
-    if (i % 2) {
-      ownKeys(Object(source), true).forEach(function (key) {
-        _defineProperty(target, key, source[key]);
-      });
-    } else if (Object.getOwnPropertyDescriptors) {
-      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
-    } else {
-      ownKeys(Object(source)).forEach(function (key) {
-        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
-      });
-    }
+    var source = null != arguments[i] ? arguments[i] : {};
+    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
+      _defineProperty(target, key, source[key]);
+    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
+      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
+    });
   }
 
   return target;
 }
 
-const pkgPath = path__default['default'].dirname(require.resolve("@changesets/cli/package.json")); // Modify base branch to "main" without changing defaultWrittenConfig since it also serves as a fallback
+const pkgPath = path__default["default"].dirname(require.resolve("@changesets/cli/package.json")); // Modify base branch to "main" without changing defaultWrittenConfig since it also serves as a fallback
 // for config files that don't specify a base branch. Changing that to main would be a breaking change.
 
 const defaultConfig = JSON.stringify(_objectSpread2(_objectSpread2({}, config.defaultWrittenConfig), {}, {
   baseBranch: "main"
 }), null, 2);
 async function init(cwd) {
-  const changesetBase = path__default['default'].resolve(cwd, ".changeset");
+  const changesetBase = path__default["default"].resolve(cwd, ".changeset");
 
-  if (fs__default['default'].existsSync(changesetBase)) {
-    if (!fs__default['default'].existsSync(path__default['default'].join(changesetBase, "config.json"))) {
-      if (fs__default['default'].existsSync(path__default['default'].join(changesetBase, "config.js"))) {
+  if (fs__default["default"].existsSync(changesetBase)) {
+    if (!fs__default["default"].existsSync(path__default["default"].join(changesetBase, "config.json"))) {
+      if (fs__default["default"].existsSync(path__default["default"].join(changesetBase, "config.js"))) {
         logger.error("It looks like you're using the version 1 `.changeset/config.js` file");
         logger.error("The format of the config object has significantly changed in v2 as well");
         logger.error(" - we thoroughly recommend looking at the changelog for this package for what has changed");
@@ -122,18 +135,18 @@ async function init(cwd) {
         logger.info("The default config file will be written at `.changeset/config.json`");
       }
 
-      await fs__default['default'].writeFile(path__default['default'].resolve(changesetBase, "config.json"), defaultConfig);
+      await fs__default["default"].writeFile(path__default["default"].resolve(changesetBase, "config.json"), defaultConfig);
     } else {
       logger.warn("It looks like you already have changesets initialized. You should be able to run changeset commands no problems.");
     }
   } else {
-    await fs__default['default'].copy(path__default['default'].resolve(pkgPath, "./default-files"), changesetBase);
-    await fs__default['default'].writeFile(path__default['default'].resolve(changesetBase, "config.json"), defaultConfig);
-    logger.log(chalk__default['default']`Thanks for choosing {green changesets} to help manage your versioning and publishing\n`);
+    await fs__default["default"].copy(path__default["default"].resolve(pkgPath, "./default-files"), changesetBase);
+    await fs__default["default"].writeFile(path__default["default"].resolve(changesetBase, "config.json"), defaultConfig);
+    logger.log(chalk__default["default"]`Thanks for choosing {green changesets} to help manage your versioning and publishing\n`);
     logger.log("You should be set up to start using changesets now!\n");
     logger.info("We have added a `.changeset` folder, and a couple of files to help you out:");
-    logger.info(chalk__default['default']`- {blue .changeset/README.md} contains information about using changesets`);
-    logger.info(chalk__default['default']`- {blue .changeset/config.json} is our default config`);
+    logger.info(chalk__default["default"]`- {blue .changeset/README.md} contains information about using changesets`);
+    logger.info(chalk__default["default"]`- {blue .changeset/config.json} is our default config`);
   }
 }
 
@@ -150,7 +163,7 @@ const serialId = function () {
   return () => id++;
 }();
 
-const limit = Math.max(termSize__default['default']().rows - 5, 10);
+const limit = Math.max(termSize__default["default"]().rows - 5, 10);
 
 let cancelFlow = () => {
   logger.success("Cancelled... 👋 ");
@@ -239,8 +252,8 @@ function getCommitFunctions(commit, cwd) {
   }
 
   let commitOpts = commit[1];
-  let changesetPath = path__default['default'].join(cwd, ".changeset");
-  let commitPath = resolveFrom__default['default'](changesetPath, commit[0]);
+  let changesetPath = path__default["default"].join(cwd, ".changeset");
+  let commitPath = resolveFrom__default["default"](changesetPath, commit[0]);
 
   let possibleCommitFunc = require(commitPath);
 
@@ -264,10 +277,10 @@ const {
   bold,
   blue,
   cyan
-} = chalk__default['default'];
+} = chalk__default["default"];
 
 async function confirmMajorRelease(pkgJSON) {
-  if (semver__default['default'].lt(pkgJSON.version, "1.0.0")) {
+  if (semver__default["default"].lt(pkgJSON.version, "1.0.0")) {
     // prettier-ignore
     logger.log(yellow(`WARNING: Releasing a major version for ${green(pkgJSON.name)} will be its ${red('first major release')}.`));
     logger.log(yellow(`If you are unsure if this is correct, contact the package's maintainers ${red("before committing this changeset")}.`));
@@ -278,7 +291,7 @@ async function confirmMajorRelease(pkgJSON) {
   return true;
 }
 
-async function getPackagesToRelease(changedPackages, allPackages) {
+async function getPackagesToRelease(changedPackages, allPackages, ignorePrivatePackages) {
   function askInitialReleaseQuestion(defaultChoiceList) {
     return askCheckboxPlus( // TODO: Make this wording better
     // TODO: take objects and be fancy with matching
@@ -293,6 +306,11 @@ async function getPackagesToRelease(changedPackages, allPackages) {
     });
   }
 
+  const pkgJsonsByName = getPkgJsonsByName(allPackages); // filter out packages which changesets is not tracking
+
+  allPackages = allPackages.filter(pkg => isValidChangesetPackage(pkg.packageJson, ignorePrivatePackages));
+  changedPackages = changedPackages.filter(pkgName => !isValidChangesetPackage(pkgJsonsByName.get(pkgName), ignorePrivatePackages));
+
   if (allPackages.length > 1) {
     const unchangedPackagesNames = allPackages.map(({
       packageJson
@@ -322,18 +340,32 @@ async function getPackagesToRelease(changedPackages, allPackages) {
   return [allPackages[0].packageJson.name];
 }
 
+function getPkgJsonsByName(packages) {
+  return new Map(packages.map(({
+    packageJson
+  }) => [packageJson.name, packageJson]));
+}
+
+function isValidChangesetPackage(packageJson, ignorePrivatePackages) {
+  const hasVersionField = !!packageJson.version;
+
+  if (ignorePrivatePackages && packageJson.private) {
+    return false;
+  }
+
+  return hasVersionField;
+}
+
 function formatPkgNameAndVersion(pkgName, version) {
   return `${bold(pkgName)}@${bold(version)}`;
 }
 
-async function createChangeset(changedPackages, allPackages) {
+async function createChangeset(changedPackages, allPackages, ignorePrivatePackages) {
   const releases = [];
 
   if (allPackages.length > 1) {
-    const packagesToRelease = await getPackagesToRelease(changedPackages, allPackages);
-    let pkgJsonsByName = new Map(allPackages.map(({
-      packageJson
-    }) => [packageJson.name, packageJson]));
+    const packagesToRelease = await getPackagesToRelease(changedPackages, allPackages, ignorePrivatePackages);
+    let pkgJsonsByName = getPkgJsonsByName(allPackages);
     let pkgsLeftToGetBumpTypeFor = new Set(packagesToRelease);
     let pkgsThatShouldBeMajorBumped = (await askCheckboxPlus(bold(`Which packages should have a ${red("major")} bump?`), [{
       name: "all packages",
@@ -429,7 +461,7 @@ async function createChangeset(changedPackages, allPackages) {
   }
 
   logger.log("Please enter a summary for this change (this will be in the changelogs).");
-  logger.log(chalk__default['default'].gray("  (submit empty line to open external editor)"));
+  logger.log(chalk__default["default"].gray("  (submit empty line to open external editor)"));
   let summary = await askQuestion("Summary");
 
   if (summary.length === 0) {
@@ -470,15 +502,15 @@ function printConfirmationMessage(changeset, repoHasMultiplePackages) {
   const majorReleases = getReleasesOfType("major");
   const minorReleases = getReleasesOfType("minor");
   const patchReleases = getReleasesOfType("patch");
-  if (majorReleases.length > 0) logger.log(`${chalk__default['default'].bold.green("major")}:  ${majorReleases.join(", ")}`);
-  if (minorReleases.length > 0) logger.log(`${chalk__default['default'].bold.green("minor")}:  ${minorReleases.join(", ")}`);
-  if (patchReleases.length > 0) logger.log(`${chalk__default['default'].bold.green("patch")}:  ${patchReleases.join(", ")}`);
+  if (majorReleases.length > 0) logger.log(`${chalk__default["default"].bold.green("major")}:  ${majorReleases.join(", ")}`);
+  if (minorReleases.length > 0) logger.log(`${chalk__default["default"].bold.green("minor")}:  ${minorReleases.join(", ")}`);
+  if (patchReleases.length > 0) logger.log(`${chalk__default["default"].bold.green("patch")}:  ${patchReleases.join(", ")}`);
   logger.log("");
 
   if (repoHasMultiplePackages) {
-    const message = outdent__default['default']`
+    const message = outdent__default["default"]`
       Note: All dependents of these packages that will be incompatible with
-      the new version will be ${chalk__default['default'].redBright("patch bumped")} when this changeset is applied.
+      the new version will be ${chalk__default["default"].redBright("patch bumped")} when this changeset is applied.
     `;
     logger.log(message + "\n");
   }
@@ -489,7 +521,7 @@ async function add(cwd, {
   open
 }, config) {
   const packages = await getPackages.getPackages(cwd);
-  const changesetBase = path__default['default'].resolve(cwd, ".changeset");
+  const changesetBase = path__default["default"].resolve(cwd, ".changeset");
   let newChangeset;
 
   if (empty) {
@@ -499,12 +531,12 @@ async function add(cwd, {
       summary: ``
     };
   } else {
-    const changedPackages = await git.getChangedPackagesSinceRef({
+    const changedPackages = await git__namespace.getChangedPackagesSinceRef({
       cwd,
       ref: config.baseBranch
     });
     const changePackagesName = changedPackages.filter(a => a).map(pkg => pkg.packageJson.name);
-    newChangeset = await createChangeset(changePackagesName, packages.packages);
+    newChangeset = await createChangeset(changePackagesName, packages.packages, config.privatePackages === types.PrivatePackages.Ignore);
     printConfirmationMessage(newChangeset, packages.packages.length > 1);
 
     if (!newChangeset.confirmed) {
@@ -515,17 +547,17 @@ async function add(cwd, {
   }
 
   if (newChangeset.confirmed) {
-    const changesetID = await writeChangeset__default['default'](newChangeset, cwd);
+    const changesetID = await writeChangeset__default["default"](newChangeset, cwd);
     const [{
       getAddMessage
     }, commitOpts] = getCommitFunctions(config.commit, cwd);
 
     if (getAddMessage) {
-      await git.add(path__default['default'].resolve(changesetBase, `${changesetID}.md`), cwd);
-      await git.commit(await getAddMessage(newChangeset, commitOpts), cwd);
-      logger.log(chalk__default['default'].green(`${empty ? "Empty " : ""}Changeset added and committed`));
+      await git__namespace.add(path__default["default"].resolve(changesetBase, `${changesetID}.md`), cwd);
+      await git__namespace.commit(await getAddMessage(newChangeset, commitOpts), cwd);
+      logger.log(chalk__default["default"].green(`${empty ? "Empty " : ""}Changeset added and committed`));
     } else {
-      logger.log(chalk__default['default'].green(`${empty ? "Empty " : ""}Changeset added! - you can now commit it\n`));
+      logger.log(chalk__default["default"].green(`${empty ? "Empty " : ""}Changeset added! - you can now commit it\n`));
     }
 
     let hasMajorChange = [...newChangeset.releases].find(c => c.type === "major");
@@ -536,11 +568,11 @@ async function add(cwd, {
       logger.warn("WHY the change was made");
       logger.warn("HOW a consumer should update their code");
     } else {
-      logger.log(chalk__default['default'].green("If you want to modify or expand on the changeset summary, you can find it here"));
+      logger.log(chalk__default["default"].green("If you want to modify or expand on the changeset summary, you can find it here"));
     }
 
-    const changesetPath = path__default['default'].resolve(changesetBase, `${changesetID}.md`);
-    logger.info(chalk__default['default'].blue(changesetPath));
+    const changesetPath = path__default["default"].resolve(changesetBase, `${changesetID}.md`);
+    logger.info(chalk__default["default"].blue(changesetPath));
 
     if (open) {
       // this is really a hack to reuse the logic embedded in `external-editor` related to determining the editor
@@ -558,13 +590,13 @@ async function add(cwd, {
 // THIS SHOULD BE REMOVED WHEN SUPPORT FOR CHANGESETS FROM V1 IS DROPPED
 
 const removeEmptyFolders = async folderPath => {
-  const dirContents = fs__default['default'].readdirSync(folderPath);
+  const dirContents = fs__default["default"].readdirSync(folderPath);
   return Promise.all(dirContents.map(async contentPath => {
-    const singleChangesetPath = path__default['default'].resolve(folderPath, contentPath);
+    const singleChangesetPath = path__default["default"].resolve(folderPath, contentPath);
 
     try {
-      if ((await fs__default['default'].readdir(singleChangesetPath)).length < 1) {
-        await fs__default['default'].rmdir(singleChangesetPath);
+      if ((await fs__default["default"].readdir(singleChangesetPath)).length < 1) {
+        await fs__default["default"].rmdir(singleChangesetPath);
       }
     } catch (err) {
       if (err.code !== "ENOTDIR") {
@@ -574,18 +606,18 @@ const removeEmptyFolders = async folderPath => {
   }));
 };
 
-let importantSeparator = chalk__default['default'].red("===============================IMPORTANT!===============================");
-let importantEnd = chalk__default['default'].red("----------------------------------------------------------------------");
+let importantSeparator$1 = chalk__default["default"].red("===============================IMPORTANT!===============================");
+let importantEnd$1 = chalk__default["default"].red("----------------------------------------------------------------------");
 async function version(cwd, options, config) {
   const releaseConfig = _objectSpread2(_objectSpread2({}, config), {}, {
     // Disable committing when in snapshot mode
     commit: options.snapshot ? false : config.commit
   });
 
-  const [changesets, preState] = await Promise.all([readChangesets__default['default'](cwd), pre$1.readPreState(cwd), removeEmptyFolders(path__default['default'].resolve(cwd, ".changeset"))]);
+  const [changesets, preState] = await Promise.all([readChangesets__default["default"](cwd), pre$1.readPreState(cwd), removeEmptyFolders(path__default["default"].resolve(cwd, ".changeset"))]);
 
   if ((preState === null || preState === void 0 ? void 0 : preState.mode) === "pre") {
-    logger.warn(importantSeparator);
+    logger.warn(importantSeparator$1);
 
     if (options.snapshot !== undefined) {
       logger.error("Snapshot release is not allowed in pre mode");
@@ -597,7 +629,7 @@ async function version(cwd, options, config) {
       logger.warn("You can then run `changeset version` again to do a normal release");
     }
 
-    logger.warn(importantEnd);
+    logger.warn(importantEnd$1);
   }
 
   if (changesets.length === 0 && (preState === undefined || preState.mode !== "exit")) {
@@ -606,8 +638,8 @@ async function version(cwd, options, config) {
   }
 
   let packages = await getPackages.getPackages(cwd);
-  let releasePlan = assembleReleasePlan__default['default'](changesets, packages, releaseConfig, preState, options.snapshot);
-  let [...touchedFiles] = await applyReleasePlan__default['default'](releasePlan, packages, releaseConfig, options.snapshot);
+  let releasePlan = assembleReleasePlan__default["default"](changesets, packages, releaseConfig, preState, options.snapshot);
+  let [...touchedFiles] = await applyReleasePlan__default["default"](releasePlan, packages, releaseConfig, options.snapshot);
   const [{
     getVersionMessage
   }, commitOpts] = getCommitFunctions(releaseConfig.commit, cwd);
@@ -617,10 +649,10 @@ async function version(cwd, options, config) {
     // So we need to be careful that these iterations are properly sequential
 
     while (touchedFile = touchedFiles.shift()) {
-      await git.add(path__default['default'].relative(cwd, touchedFile), cwd);
+      await git__namespace.add(path__default["default"].relative(cwd, touchedFile), cwd);
     }
 
-    const commit = await git.commit(await getVersionMessage(releasePlan, commitOpts), cwd);
+    const commit = await git__namespace.commit(await getVersionMessage(releasePlan, commitOpts), cwd);
 
     if (!commit) {
       logger.error("Changesets ran into trouble committing your files");
@@ -649,8 +681,8 @@ const getLastJsonObjectFromString = str => {
   return null;
 };
 
-const npmRequestLimit = pLimit__default['default'](40);
-const npmPublishLimit = pLimit__default['default'](10);
+const npmRequestLimit = pLimit__default["default"](40);
+const npmPublishLimit = pLimit__default["default"](10);
 
 function jsonParse(input) {
   try {
@@ -672,17 +704,17 @@ function getCorrectRegistry(packageJson) {
 }
 
 async function getPublishTool(cwd) {
-  const pm = await preferredPM__default['default'](cwd);
+  const pm = await preferredPM__default["default"](cwd);
   if (!pm || pm.name !== "pnpm") return {
     name: "npm"
   };
 
   try {
-    let result = await spawn__default['default']("pnpm", ["--version"], {
+    let result = await spawn__default["default"]("pnpm", ["--version"], {
       cwd
     });
     let version = result.stdout.toString().trim();
-    let parsed = semver__default['default'].parse(version);
+    let parsed = semver__default["default"].parse(version);
     return {
       name: "pnpm",
       shouldAddNoGitChecks: (parsed === null || parsed === void 0 ? void 0 : parsed.major) === undefined ? false : parsed.major >= 5
@@ -701,7 +733,7 @@ async function getTokenIsRequired() {
   const envOverride = {
     npm_config_registry: getCorrectRegistry()
   };
-  let result = await spawn__default['default']("npm", ["profile", "get", "--json"], {
+  let result = await spawn__default["default"]("npm", ["profile", "get", "--json"], {
     env: Object.assign({}, process.env, envOverride)
   });
 
@@ -727,7 +759,7 @@ function getPackageInfo(packageJson) {
     // as they will always give a 404, which will tell `publish` to always try to publish.
     // See: https://github.com/yarnpkg/yarn/issues/2935#issuecomment-355292633
 
-    let result = await spawn__default['default']("npm", ["info", packageJson.name, "--registry", getCorrectRegistry(packageJson), "--json"]); // Github package registry returns empty string when calling npm info
+    let result = await spawn__default["default"]("npm", ["info", packageJson.name, "--registry", getCorrectRegistry(packageJson), "--json"]); // Github package registry returns empty string when calling npm info
     // for a non-existent package instead of a E404
 
     if (result.stdout.toString() === "") {
@@ -747,7 +779,7 @@ async function infoAllow404(packageJson) {
   let pkgInfo = await getPackageInfo(packageJson);
 
   if (((_pkgInfo$error = pkgInfo.error) === null || _pkgInfo$error === void 0 ? void 0 : _pkgInfo$error.code) === "E404") {
-    logger.warn(`Received 404 for npm info ${chalk__default['default'].cyan(`"${packageJson.name}"`)}`);
+    logger.warn(`Received 404 for npm info ${chalk__default["default"].cyan(`"${packageJson.name}"`)}`);
     return {
       published: false,
       pkgInfo: {}
@@ -755,7 +787,7 @@ async function infoAllow404(packageJson) {
   }
 
   if (pkgInfo.error) {
-    logger.error(`Received an unknown error code: ${pkgInfo.error.code} for npm info ${chalk__default['default'].cyan(`"${packageJson.name}"`)}`);
+    logger.error(`Received an unknown error code: ${pkgInfo.error.code} for npm info ${chalk__default["default"].cyan(`"${packageJson.name}"`)}`);
     logger.error(pkgInfo.error.summary);
     if (pkgInfo.error.detail) logger.error(pkgInfo.error.detail);
     throw new errors.ExitError(1);
@@ -766,7 +798,7 @@ async function infoAllow404(packageJson) {
     pkgInfo
   };
 }
-let otpAskLimit = pLimit__default['default'](1);
+let otpAskLimit = pLimit__default["default"](1);
 
 let askForOtpCode = twoFactorState => otpAskLimit(async () => {
   if (twoFactorState.token !== null) return twoFactorState.token;
@@ -790,7 +822,7 @@ async function internalPublish(pkgName, opts, twoFactorState) {
   let publishFlags = opts.access ? ["--access", opts.access] : [];
   publishFlags.push("--tag", opts.tag);
 
-  if ((await twoFactorState.isRequired) && !isCI__default['default']) {
+  if ((await twoFactorState.isRequired) && !isCI__default["default"]) {
     let otpCode = await getOtpCode(twoFactorState);
     publishFlags.push("--otp", otpCode);
   }
@@ -808,7 +840,7 @@ async function internalPublish(pkgName, opts, twoFactorState) {
     code,
     stdout,
     stderr
-  } = await spawn__default['default'](publishTool.name, ["publish", opts.cwd, "--json", ...publishFlags], {
+  } = await spawn__default["default"](publishTool.name, ["publish", opts.cwd, "--json", ...publishFlags], {
     env: Object.assign({}, process.env, envOverride)
   });
 
@@ -820,9 +852,9 @@ async function internalPublish(pkgName, opts, twoFactorState) {
     // Note that the `--json` output is always printed at the end so this should work
     let json = getLastJsonObjectFromString(stderr.toString()) || getLastJsonObjectFromString(stdout.toString());
 
-    if (json === null || json === void 0 ? void 0 : json.error) {
+    if (json !== null && json !== void 0 && json.error) {
       // The first case is no 2fa provided, the second is when the 2fa is wrong (timeout or wrong words)
-      if ((json.error.code === "EOTP" || json.error.code === "E401" && json.error.detail.includes("--otp=<code>")) && !isCI__default['default']) {
+      if ((json.error.code === "EOTP" || json.error.code === "E401" && json.error.detail.includes("--otp=<code>")) && !isCI__default["default"]) {
         if (twoFactorState.token !== null) {
           // the current otp code must be invalid since it errored
           twoFactorState.token = null;
@@ -876,7 +908,7 @@ const getTwoFactorState = ({
     };
   }
 
-  if (isCI__default['default'] || publicPackages.some(pkg => {
+  if (isCI__default["default"] || publicPackages.some(pkg => {
     var _pkg$packageJson$publ;
 
     return isCustomRegistry((_pkg$packageJson$publ = pkg.packageJson.publishConfig) === null || _pkg$packageJson$publ === void 0 ? void 0 : _pkg$packageJson$publ.registry);
@@ -899,24 +931,59 @@ async function publishPackages({
   access,
   otp,
   preState,
-  tag
+  tag,
+  tagPrivatePackages
 }) {
   const packagesByName = new Map(packages.map(x => [x.packageJson.name, x]));
   const publicPackages = packages.filter(pkg => !pkg.packageJson.private);
-  const twoFactorState = getTwoFactorState({
+  const privatePackages = packages.filter(pkg => pkg.packageJson.private && pkg.packageJson.version);
+  const unpublishedPackagesInfo = await getUnpublishedPackages(publicPackages, preState);
+  const twoFactorState = unpublishedPackagesInfo.length > 0 ? getTwoFactorState({
     otp,
     publicPackages
-  });
-  const unpublishedPackagesInfo = await getUnpublishedPackages(publicPackages, preState);
+  }) : {
+    token: null,
+    isRequired: Promise.resolve(false)
+  };
+  const npmPackagePublish = Promise.all(unpublishedPackagesInfo.map(pkgInfo => {
+    let pkg = packagesByName.get(pkgInfo.name);
+    return publishAPackage(pkg, access, twoFactorState, getReleaseTag(pkgInfo, preState, tag));
+  }));
+  const untaggedPrivatePackageReleases = tagPrivatePackages ? getUntaggedPrivatePackages(privatePackages) : Promise.resolve([]);
+  const result = {
+    publishedPackages: await npmPackagePublish,
+    untaggedPrivatePackages: await untaggedPrivatePackageReleases
+  };
 
-  if (unpublishedPackagesInfo.length === 0) {
-    logger.warn("No unpublished packages to publish");
+  if (result.publishedPackages.length === 0 && result.untaggedPrivatePackages.length === 0) {
+    logger.warn("No unpublished projects to publish");
   }
 
-  return Promise.all(unpublishedPackagesInfo.map(pkgInfo => {
-    let pkg = packagesByName.get(pkgInfo.name);
-    return publishAPackage(pkg, access, twoFactorState, getReleaseTag(pkgInfo, preState, tag));
+  return result;
+}
+
+async function getUntaggedPrivatePackages(privatePackages) {
+  const packageWithTags = await Promise.all(privatePackages.map(async privatePkg => {
+    const tagName = `${privatePkg.packageJson.name}@${privatePkg.packageJson.version}`;
+    const isMissingTag = !(await git__namespace.remoteTagExists(tagName));
+    return {
+      pkg: privatePkg,
+      isMissingTag
+    };
   }));
+  const untagged = [];
+
+  for (const packageWithTag of packageWithTags) {
+    if (packageWithTag.isMissingTag) {
+      untagged.push({
+        name: packageWithTag.pkg.packageJson.name,
+        newVersion: packageWithTag.pkg.packageJson.version,
+        published: false
+      });
+    }
+  }
+
+  return untagged;
 }
 
 async function publishAPackage(pkg, access, twoFactorState, tag) {
@@ -926,8 +993,8 @@ async function publishAPackage(pkg, access, twoFactorState, tag) {
     publishConfig
   } = pkg.packageJson;
   const localAccess = publishConfig === null || publishConfig === void 0 ? void 0 : publishConfig.access;
-  logger.info(`Publishing ${chalk__default['default'].cyan(`"${name}"`)} at ${chalk__default['default'].green(`"${version}"`)}`);
-  const publishDir = (publishConfig === null || publishConfig === void 0 ? void 0 : publishConfig.directory) ? path.join(pkg.dir, publishConfig.directory) : pkg.dir;
+  logger.info(`Publishing ${chalk__default["default"].cyan(`"${name}"`)} at ${chalk__default["default"].green(`"${version}"`)}`);
+  const publishDir = publishConfig !== null && publishConfig !== void 0 && publishConfig.directory ? path.join(pkg.dir, publishConfig.directory) : pkg.dir;
   const publishConfirmation = await publish(name, {
     cwd: publishDir,
     access: localAccess || access,
@@ -951,7 +1018,7 @@ async function getUnpublishedPackages(packages, preState) {
       publishedState = "published";
 
       if (preState !== undefined) {
-        if (response.pkgInfo.versions && response.pkgInfo.versions.every(version => semver__default['default'].parse(version).prerelease[0] === preState.tag)) {
+        if (response.pkgInfo.versions && response.pkgInfo.versions.every(version => semver__default["default"].parse(version).prerelease[0] === preState.tag)) {
           publishedState = "only-pre";
         }
       }
@@ -979,7 +1046,7 @@ async function getUnpublishedPackages(packages, preState) {
       logger.info(`${name} is being published because our local version (${localVersion}) has not been published on npm`);
 
       if (preState !== undefined && publishedState === "only-pre") {
-        logger.info(`${name} is being published to ${chalk__default['default'].cyan("latest")} rather than ${chalk__default['default'].cyan(preState.tag)} because there has not been a regular release of it yet`);
+        logger.info(`${name} is being published to ${chalk__default["default"].cyan("latest")} rather than ${chalk__default["default"].cyan(preState.tag)} because there has not been a regular release of it yet`);
       }
     } else {
       // If the local version is behind npm, something is wrong, we warn here, and by not getting published later, it will fail
@@ -995,23 +1062,23 @@ function logReleases(pkgs) {
   logger.log(mappedPkgs);
 }
 
-let importantSeparator$1 = chalk__default['default'].red("===============================IMPORTANT!===============================");
-let importantEnd$1 = chalk__default['default'].red("----------------------------------------------------------------------");
+let importantSeparator = chalk__default["default"].red("===============================IMPORTANT!===============================");
+let importantEnd = chalk__default["default"].red("----------------------------------------------------------------------");
 
 function showNonLatestTagWarning(tag, preState) {
-  logger.warn(importantSeparator$1);
+  logger.warn(importantSeparator);
 
   if (preState) {
-    logger.warn(`You are in prerelease mode so packages will be published to the ${chalk__default['default'].cyan(preState.tag)}
-        dist tag except for packages that have not had normal releases which will be published to ${chalk__default['default'].cyan("latest")}`);
+    logger.warn(`You are in prerelease mode so packages will be published to the ${chalk__default["default"].cyan(preState.tag)}
+        dist tag except for packages that have not had normal releases which will be published to ${chalk__default["default"].cyan("latest")}`);
   } else if (tag !== "latest") {
     logger.warn(`Packages will be released under the ${tag} tag`);
   }
 
-  logger.warn(importantEnd$1);
+  logger.warn(importantEnd);
 }
 
-async function run(cwd, {
+async function run$2(cwd, {
   otp,
   tag,
   gitTag = true
@@ -1039,42 +1106,65 @@ async function run(cwd, {
     access: config.access,
     otp,
     preState,
-    tag: releaseTag
+    tag: releaseTag,
+    tagPrivatePackages: isFlagEnabled(config.privatePackages, types.PrivatePackages.Tag)
   });
-  const successful = response.filter(p => p.published);
-  const unsuccessful = response.filter(p => !p.published);
+  const successfulNpmPublishes = response.publishedPackages.filter(p => p.published);
+  const unsuccessfulNpmPublishes = response.publishedPackages.filter(p => !p.published);
+  const untaggedPrivatePackages = response.untaggedPrivatePackages;
 
-  if (successful.length > 0) {
+  if (successfulNpmPublishes.length > 0) {
     logger.success("packages published successfully:");
-    logReleases(successful);
+    logReleases(successfulNpmPublishes);
 
     if (gitTag) {
       // We create the tags after the push above so that we know that HEAD won't change and that pushing
       // won't suffer from a race condition if another merge happens in the mean time (pushing tags won't
       // fail if we are behind the base branch).
-      logger.log(`Creating git tag${successful.length > 1 ? "s" : ""}...`);
+      logger.log(`Creating git tag${successfulNpmPublishes.length > 1 ? "s" : ""}...`);
 
       if (tool !== "root") {
-        for (const pkg of successful) {
+        for (const pkg of successfulNpmPublishes) {
           const tag = `${pkg.name}@${pkg.newVersion}`;
           logger.log("New tag: ", tag);
-          await git.tag(tag, cwd);
+          await git__namespace.tag(tag, cwd);
         }
       } else {
-        const tag = `v${successful[0].newVersion}`;
+        const tag = `v${successfulNpmPublishes[0].newVersion}`;
         logger.log("New tag: ", tag);
-        await git.tag(tag, cwd);
+        await git__namespace.tag(tag, cwd);
       }
     }
   }
 
-  if (unsuccessful.length > 0) {
+  if (untaggedPrivatePackages.length > 0) {
+    logger.success("found untagged projects:");
+    logReleases(untaggedPrivatePackages);
+
+    if (tool !== "root") {
+      for (const pkg of untaggedPrivatePackages) {
+        const tag = `${pkg.name}@${pkg.newVersion}`;
+        logger.log("New tag: ", tag);
+        await git__namespace.tag(tag, cwd);
+      }
+    } else {
+      const tag = `v${untaggedPrivatePackages[0].newVersion}`;
+      logger.log("New tag: ", tag);
+      await git__namespace.tag(tag, cwd);
+    }
+  }
+
+  if (unsuccessfulNpmPublishes.length > 0) {
     logger.error("packages failed to publish:");
-    logReleases(unsuccessful);
+    logReleases(unsuccessfulNpmPublishes);
     throw new errors.ExitError(1);
   }
 }
 
+function isFlagEnabled(value, tag) {
+  return (value & tag) === tag;
+}
+
 async function getStatus(cwd, {
   sinceMaster,
   since,
@@ -1087,12 +1177,12 @@ async function getStatus(cwd, {
   }
 
   const sinceBranch = since === undefined ? sinceMaster ? "master" : undefined : since;
-  const releasePlan = await getReleasePlan__default['default'](cwd, sinceBranch, config);
+  const releasePlan = await getReleasePlan__default["default"](cwd, sinceBranch, config);
   const {
     changesets,
     releases
   } = releasePlan;
-  const changedPackages = await git.getChangedPackagesSinceRef({
+  const changedPackages = await git__namespace.getChangedPackagesSinceRef({
     cwd,
     ref: sinceBranch || config.baseBranch
   });
@@ -1104,7 +1194,7 @@ async function getStatus(cwd, {
   }
 
   if (output) {
-    await fs__default['default'].writeFile(path__default['default'].join(cwd, output), JSON.stringify(releasePlan, undefined, 2));
+    await fs__default["default"].writeFile(path__default["default"].join(cwd, output), JSON.stringify(releasePlan, undefined, 2));
     return;
   }
 
@@ -1121,13 +1211,13 @@ function SimplePrint(type, releases) {
   const packages = releases.filter(r => r.type === type);
 
   if (packages.length) {
-    logger.info(chalk__default['default']`Packages to be bumped at {green ${type}}:\n`);
+    logger.info(chalk__default["default"]`Packages to be bumped at {green ${type}}:\n`);
     const pkgs = packages.map(({
       name
     }) => `- ${name}`).join("\n");
-    logger.log(chalk__default['default'].green(pkgs));
+    logger.log(chalk__default["default"].green(pkgs));
   } else {
-    logger.info(chalk__default['default']`{red NO} packages to be bumped at {green ${type}}`);
+    logger.info(chalk__default["default"]`{red NO} packages to be bumped at {green ${type}}`);
   }
 }
 
@@ -1135,13 +1225,13 @@ function verbosePrint(type, releases) {
   const packages = releases.filter(r => r.type === type);
 
   if (packages.length) {
-    logger.info(chalk__default['default']`Packages to be bumped at {green ${type}}`);
+    logger.info(chalk__default["default"]`Packages to be bumped at {green ${type}}`);
     const columns = packages.map(({
       name,
       newVersion: version,
       changesets
-    }) => [chalk__default['default'].green(name), version, changesets.map(c => chalk__default['default'].blue(` .changeset/${c}/changes.md`)).join(" +")]);
-    const t1 = table__default['default']([{
+    }) => [chalk__default["default"].green(name), version, changesets.map(c => chalk__default["default"].blue(` .changeset/${c}.md`)).join(" +")]);
+    const t1 = table__default["default"]([{
       value: "Package Name",
       width: 20
     }, {
@@ -1158,7 +1248,7 @@ function verbosePrint(type, releases) {
     });
     logger.log(t1.render() + "\n");
   } else {
-    logger.info(chalk__default['default']`Running release would release {red NO} packages as a {green ${type}}`);
+    logger.info(chalk__default["default"]`Running release would release {red NO} packages as a {green ${type}}`);
   }
 }
 
@@ -1166,12 +1256,12 @@ async function pre(cwd, options) {
   if (options.command === "enter") {
     try {
       await pre$1.enterPre(cwd, options.tag);
-      logger.success(`Entered pre mode with tag ${chalk__default['default'].cyan(options.tag)}`);
-      logger.info("Run `changeset version` to version packages with prerelease versions");
+      logger__namespace.success(`Entered pre mode with tag ${chalk__default["default"].cyan(options.tag)}`);
+      logger__namespace.info("Run `changeset version` to version packages with prerelease versions");
     } catch (err) {
       if (err instanceof errors.PreEnterButInPreModeError) {
-        logger.error("`changeset pre enter` cannot be run when in pre mode");
-        logger.info("If you're trying to exit pre mode, run `changeset pre exit`");
+        logger__namespace.error("`changeset pre enter` cannot be run when in pre mode");
+        logger__namespace.info("If you're trying to exit pre mode, run `changeset pre exit`");
         throw new errors.ExitError(1);
       }
 
@@ -1180,12 +1270,12 @@ async function pre(cwd, options) {
   } else {
     try {
       await pre$1.exitPre(cwd);
-      logger.success(`Exited pre mode`);
-      logger.info("Run `changeset version` to version packages with normal versions");
+      logger__namespace.success(`Exited pre mode`);
+      logger__namespace.info("Run `changeset version` to version packages with normal versions");
     } catch (err) {
       if (err instanceof errors.PreExitButNotInPreModeError) {
-        logger.error("`changeset pre exit` can only be run when in pre mode");
-        logger.info("If you're trying to enter pre mode, run `changeset pre enter`");
+        logger__namespace.error("`changeset pre exit` can only be run when in pre mode");
+        logger__namespace.info("If you're trying to enter pre mode, run `changeset pre enter`");
         throw new errors.ExitError(1);
       }
 
@@ -1199,7 +1289,7 @@ async function run$1(cwd) {
     packages,
     tool
   } = await getPackages.getPackages(cwd);
-  const allExistingTags = await git.getAllTags(cwd);
+  const allExistingTags = await git__namespace.getAllTags(cwd);
 
   for (const pkg of packages) {
     const tag = tool !== "root" ? `${pkg.packageJson.name}@${pkg.packageJson.version}` : `v${pkg.packageJson.version}`;
@@ -1208,18 +1298,18 @@ async function run$1(cwd) {
       logger.log("Skipping tag (already exists): ", tag);
     } else {
       logger.log("New tag: ", tag);
-      await git.tag(tag, cwd);
+      await git__namespace.tag(tag, cwd);
     }
   }
 }
 
-async function run$2(input, flags, cwd) {
+async function run(input, flags, cwd) {
   if (input[0] === "init") {
     await init(cwd);
     return;
   }
 
-  if (!fs__default['default'].existsSync(path__default['default'].resolve(cwd, ".changeset"))) {
+  if (!fs__default["default"].existsSync(path__default["default"].resolve(cwd, ".changeset"))) {
     logger.error("There is no .changeset folder. ");
     logger.error("If this is the first time `changesets` have been used in this project, run `yarn changeset init` to get set up.");
     logger.error("If you expected there to be changesets, you should check git history for when the folder was removed to ensure you do not lose any configuration.");
@@ -1232,7 +1322,7 @@ async function run$2(input, flags, cwd) {
   try {
     config$1 = await config.read(cwd, packages);
   } catch (e) {
-    let oldConfigExists = await fs__default['default'].pathExists(path__default['default'].resolve(cwd, ".changeset/config.js"));
+    let oldConfigExists = await fs__default["default"].pathExists(path__default["default"].resolve(cwd, ".changeset/config.js"));
 
     if (oldConfigExists) {
       logger.error("It looks like you're using the version 1 `.changeset/config.js` file");
@@ -1352,7 +1442,7 @@ async function run$2(input, flags, cwd) {
 
       case "publish":
         {
-          await run(cwd, {
+          await run$2(cwd, {
             otp,
             tag,
             gitTag
@@ -1427,7 +1517,7 @@ async function run$2(input, flags, cwd) {
 const {
   input,
   flags
-} = meow__default['default'](`
+} = meow__default["default"](`
   Usage
     $ changeset [command]
   Commands
@@ -1480,7 +1570,7 @@ const {
   }
 });
 const cwd = process.cwd();
-run$2(input, flags, cwd).catch(err => {
+run(input, flags, cwd).catch(err => {
   if (err instanceof errors.InternalError) {
     logger.error("The following error is an internal unexpected error, these should never happen.");
     logger.error("Please open an issue with the following link");
diff --git a/node_modules/@changesets/cli/dist/cli.cjs.prod.js b/node_modules/@changesets/cli/dist/cli.cjs.prod.js
index 734b9e4..b158a0b 100644
--- a/node_modules/@changesets/cli/dist/cli.cjs.prod.js
+++ b/node_modules/@changesets/cli/dist/cli.cjs.prod.js
@@ -1,6 +1,6 @@
 "use strict";
 
-var meow = require("meow"), errors = require("@changesets/errors"), logger = require("@changesets/logger"), util = require("util"), fs = require("fs-extra"), path = require("path"), getPackages = require("@manypkg/get-packages"), getDependentsGraph = require("@changesets/get-dependents-graph"), config = require("@changesets/config"), chalk = require("chalk"), child_process = require("child_process"), termSize = require("term-size"), enquirer = require("enquirer"), externalEditor = require("external-editor"), ansiColors = require("ansi-colors"), git = require("@changesets/git"), writeChangeset = require("@changesets/write"), resolveFrom = require("resolve-from"), semver = require("semver"), outdent = require("outdent"), applyReleasePlan = require("@changesets/apply-release-plan"), readChangesets = require("@changesets/read"), assembleReleasePlan = require("@changesets/assemble-release-plan"), pre$1 = require("@changesets/pre"), pLimit = require("p-limit"), preferredPM = require("preferred-pm"), spawn = require("spawndamnit"), isCI = require("is-ci"), table = require("tty-table"), getReleasePlan = require("@changesets/get-release-plan");
+var meow = require("meow"), errors = require("@changesets/errors"), logger = require("@changesets/logger"), util = require("util"), fs = require("fs-extra"), path = require("path"), getPackages = require("@manypkg/get-packages"), getDependentsGraph = require("@changesets/get-dependents-graph"), config = require("@changesets/config"), chalk = require("chalk"), child_process = require("child_process"), termSize = require("term-size"), enquirer = require("enquirer"), externalEditor = require("external-editor"), ansiColors = require("ansi-colors"), git = require("@changesets/git"), types = require("@changesets/types"), writeChangeset = require("@changesets/write"), resolveFrom = require("resolve-from"), semver = require("semver"), outdent = require("outdent"), applyReleasePlan = require("@changesets/apply-release-plan"), readChangesets = require("@changesets/read"), assembleReleasePlan = require("@changesets/assemble-release-plan"), pre$1 = require("@changesets/pre"), pLimit = require("p-limit"), preferredPM = require("preferred-pm"), spawn = require("spawndamnit"), isCI = require("is-ci"), table = require("tty-table"), getReleasePlan = require("@changesets/get-release-plan");
 
 function _interopDefault(e) {
   return e && e.__esModule ? e : {
@@ -8,7 +8,23 @@ function _interopDefault(e) {
   };
 }
 
-var meow__default = _interopDefault(meow), fs__default = _interopDefault(fs), path__default = _interopDefault(path), chalk__default = _interopDefault(chalk), termSize__default = _interopDefault(termSize), writeChangeset__default = _interopDefault(writeChangeset), resolveFrom__default = _interopDefault(resolveFrom), semver__default = _interopDefault(semver), outdent__default = _interopDefault(outdent), applyReleasePlan__default = _interopDefault(applyReleasePlan), readChangesets__default = _interopDefault(readChangesets), assembleReleasePlan__default = _interopDefault(assembleReleasePlan), pLimit__default = _interopDefault(pLimit), preferredPM__default = _interopDefault(preferredPM), spawn__default = _interopDefault(spawn), isCI__default = _interopDefault(isCI), table__default = _interopDefault(table), getReleasePlan__default = _interopDefault(getReleasePlan);
+function _interopNamespace(e) {
+  if (e && e.__esModule) return e;
+  var n = Object.create(null);
+  return e && Object.keys(e).forEach((function(k) {
+    if ("default" !== k) {
+      var d = Object.getOwnPropertyDescriptor(e, k);
+      Object.defineProperty(n, k, d.get ? d : {
+        enumerable: !0,
+        get: function() {
+          return e[k];
+        }
+      });
+    }
+  })), n.default = e, Object.freeze(n);
+}
+
+var meow__default = _interopDefault(meow), logger__namespace = _interopNamespace(logger), fs__default = _interopDefault(fs), path__default = _interopDefault(path), chalk__default = _interopDefault(chalk), termSize__default = _interopDefault(termSize), git__namespace = _interopNamespace(git), writeChangeset__default = _interopDefault(writeChangeset), resolveFrom__default = _interopDefault(resolveFrom), semver__default = _interopDefault(semver), outdent__default = _interopDefault(outdent), applyReleasePlan__default = _interopDefault(applyReleasePlan), readChangesets__default = _interopDefault(readChangesets), assembleReleasePlan__default = _interopDefault(assembleReleasePlan), pLimit__default = _interopDefault(pLimit), preferredPM__default = _interopDefault(preferredPM), spawn__default = _interopDefault(spawn), isCI__default = _interopDefault(isCI), table__default = _interopDefault(table), getReleasePlan__default = _interopDefault(getReleasePlan);
 
 function _defineProperty(obj, key, value) {
   return key in obj ? Object.defineProperty(obj, key, {
@@ -71,7 +87,7 @@ let cancelFlow = () => {
 };
 
 async function askCheckboxPlus(message, choices, format) {
-  const name = "CheckboxPlus-" + serialId();
+  const name = `CheckboxPlus-${serialId()}`;
   return enquirer.prompt({
     type: "autocomplete",
     name: name,
@@ -93,7 +109,7 @@ async function askCheckboxPlus(message, choices, format) {
 }
 
 async function askQuestion(message) {
-  const name = "Question-" + serialId();
+  const name = `Question-${serialId()}`;
   return enquirer.prompt([ {
     type: "input",
     message: message,
@@ -112,7 +128,7 @@ function askQuestionWithEditor(message) {
 }
 
 async function askConfirm(message) {
-  const name = "Confirm-" + serialId();
+  const name = `Confirm-${serialId()}`;
   return enquirer.prompt([ {
     message: message,
     name: name,
@@ -126,7 +142,7 @@ async function askConfirm(message) {
 }
 
 async function askList(message, choices) {
-  const name = "List-" + serialId();
+  const name = `List-${serialId()}`;
   return enquirer.prompt([ {
     choices: choices,
     message: message,
@@ -159,11 +175,14 @@ async function confirmMajorRelease(pkgJSON) {
   return !0;
 }
 
-async function getPackagesToRelease(changedPackages, allPackages) {
+async function getPackagesToRelease(changedPackages, allPackages, ignorePrivatePackages) {
   function askInitialReleaseQuestion(defaultChoiceList) {
     return askCheckboxPlus("Which packages would you like to include?", defaultChoiceList, (x => Array.isArray(x) ? x.filter((x => "changed packages" !== x && "unchanged packages" !== x)).map((x => cyan(x))).join(", ") : x));
   }
-  if (allPackages.length > 1) {
+  const pkgJsonsByName = getPkgJsonsByName(allPackages);
+  if (allPackages = allPackages.filter((pkg => isValidChangesetPackage(pkg.packageJson, ignorePrivatePackages))), 
+  changedPackages = changedPackages.filter((pkgName => !isValidChangesetPackage(pkgJsonsByName.get(pkgName), ignorePrivatePackages))), 
+  allPackages.length > 1) {
     const unchangedPackagesNames = allPackages.map((({packageJson: packageJson}) => packageJson.name)).filter((name => !changedPackages.includes(name))), defaultChoiceList = [ {
       name: "changed packages",
       choices: changedPackages
@@ -181,15 +200,24 @@ async function getPackagesToRelease(changedPackages, allPackages) {
   return [ allPackages[0].packageJson.name ];
 }
 
+function getPkgJsonsByName(packages) {
+  return new Map(packages.map((({packageJson: packageJson}) => [ packageJson.name, packageJson ])));
+}
+
+function isValidChangesetPackage(packageJson, ignorePrivatePackages) {
+  const hasVersionField = !!packageJson.version;
+  return (!ignorePrivatePackages || !packageJson.private) && hasVersionField;
+}
+
 function formatPkgNameAndVersion(pkgName, version) {
   return `${bold(pkgName)}@${bold(version)}`;
 }
 
-async function createChangeset(changedPackages, allPackages) {
+async function createChangeset(changedPackages, allPackages, ignorePrivatePackages) {
   const releases = [];
   if (allPackages.length > 1) {
-    const packagesToRelease = await getPackagesToRelease(changedPackages, allPackages);
-    let pkgJsonsByName = new Map(allPackages.map((({packageJson: packageJson}) => [ packageJson.name, packageJson ]))), pkgsLeftToGetBumpTypeFor = new Set(packagesToRelease), pkgsThatShouldBeMajorBumped = (await askCheckboxPlus(bold(`Which packages should have a ${red("major")} bump?`), [ {
+    const packagesToRelease = await getPackagesToRelease(changedPackages, allPackages, ignorePrivatePackages);
+    let pkgJsonsByName = getPkgJsonsByName(allPackages), pkgsLeftToGetBumpTypeFor = new Set(packagesToRelease), pkgsThatShouldBeMajorBumped = (await askCheckboxPlus(bold(`Which packages should have a ${red("major")} bump?`), [ {
       name: "all packages",
       choices: packagesToRelease.map((pkgName => ({
         name: pkgName,
@@ -286,23 +314,24 @@ async function add(cwd, {empty: empty, open: open}, config) {
     releases: [],
     summary: ""
   }; else {
-    const changePackagesName = (await git.getChangedPackagesSinceRef({
+    const changePackagesName = (await git__namespace.getChangedPackagesSinceRef({
       cwd: cwd,
       ref: config.baseBranch
     })).filter((a => a)).map((pkg => pkg.packageJson.name));
-    newChangeset = await createChangeset(changePackagesName, packages.packages), printConfirmationMessage(newChangeset, packages.packages.length > 1), 
-    newChangeset.confirmed || (newChangeset = _objectSpread2(_objectSpread2({}, newChangeset), {}, {
+    newChangeset = await createChangeset(changePackagesName, packages.packages, config.privatePackages === types.PrivatePackages.Ignore), 
+    printConfirmationMessage(newChangeset, packages.packages.length > 1), newChangeset.confirmed || (newChangeset = _objectSpread2(_objectSpread2({}, newChangeset), {}, {
       confirmed: await askConfirm("Is this your desired changeset?")
     }));
   }
   if (newChangeset.confirmed) {
     const changesetID = await writeChangeset__default.default(newChangeset, cwd), [{getAddMessage: getAddMessage}, commitOpts] = getCommitFunctions(config.commit, cwd);
-    getAddMessage ? (await git.add(path__default.default.resolve(changesetBase, changesetID + ".md"), cwd), 
-    await git.commit(await getAddMessage(newChangeset, commitOpts), cwd), logger.log(chalk__default.default.green((empty ? "Empty " : "") + "Changeset added and committed"))) : logger.log(chalk__default.default.green((empty ? "Empty " : "") + "Changeset added! - you can now commit it\n")), 
+    getAddMessage ? (await git__namespace.add(path__default.default.resolve(changesetBase, `${changesetID}.md`), cwd), 
+    await git__namespace.commit(await getAddMessage(newChangeset, commitOpts), cwd), 
+    logger.log(chalk__default.default.green((empty ? "Empty " : "") + "Changeset added and committed"))) : logger.log(chalk__default.default.green((empty ? "Empty " : "") + "Changeset added! - you can now commit it\n")), 
     [ ...newChangeset.releases ].find((c => "major" === c.type)) ? (logger.warn("This Changeset includes a major change and we STRONGLY recommend adding more information to the changeset:"), 
     logger.warn("WHAT the breaking change is"), logger.warn("WHY the change was made"), 
     logger.warn("HOW a consumer should update their code")) : logger.log(chalk__default.default.green("If you want to modify or expand on the changeset summary, you can find it here"));
-    const changesetPath = path__default.default.resolve(changesetBase, changesetID + ".md");
+    const changesetPath = path__default.default.resolve(changesetBase, `${changesetID}.md`);
     if (logger.info(chalk__default.default.blue(changesetPath)), open) {
       const externalEditor$1 = new externalEditor.ExternalEditor;
       externalEditor$1.cleanup(), child_process.spawn(externalEditor$1.editor.bin, externalEditor$1.editor.args.concat([ changesetPath ]), {
@@ -325,27 +354,27 @@ const removeEmptyFolders = async folderPath => {
   })));
 };
 
-let importantSeparator = chalk__default.default.red("===============================IMPORTANT!==============================="), importantEnd = chalk__default.default.red("----------------------------------------------------------------------");
+let importantSeparator$1 = chalk__default.default.red("===============================IMPORTANT!==============================="), importantEnd$1 = chalk__default.default.red("----------------------------------------------------------------------");
 
 async function version(cwd, options, config) {
   const releaseConfig = _objectSpread2(_objectSpread2({}, config), {}, {
     commit: !options.snapshot && config.commit
   }), [changesets, preState] = await Promise.all([ readChangesets__default.default(cwd), pre$1.readPreState(cwd), removeEmptyFolders(path__default.default.resolve(cwd, ".changeset")) ]);
   if ("pre" === (null == preState ? void 0 : preState.mode)) {
-    if (logger.warn(importantSeparator), void 0 !== options.snapshot) throw logger.error("Snapshot release is not allowed in pre mode"), 
+    if (logger.warn(importantSeparator$1), void 0 !== options.snapshot) throw logger.error("Snapshot release is not allowed in pre mode"), 
     logger.log("To resolve this exit the pre mode by running `changeset pre exit`"), 
     new errors.ExitError(1);
     logger.warn("You are in prerelease mode"), logger.warn("If you meant to do a normal release you should revert these changes and run `changeset pre exit`"), 
     logger.warn("You can then run `changeset version` again to do a normal release"), 
-    logger.warn(importantEnd);
+    logger.warn(importantEnd$1);
   }
   if (0 === changesets.length && (void 0 === preState || "exit" !== preState.mode)) return void logger.warn("No unreleased changesets found, exiting.");
   let packages = await getPackages.getPackages(cwd), releasePlan = assembleReleasePlan__default.default(changesets, packages, releaseConfig, preState, options.snapshot), [...touchedFiles] = await applyReleasePlan__default.default(releasePlan, packages, releaseConfig, options.snapshot);
   const [{getVersionMessage: getVersionMessage}, commitOpts] = getCommitFunctions(releaseConfig.commit, cwd);
   if (getVersionMessage) {
     let touchedFile;
-    for (;touchedFile = touchedFiles.shift(); ) await git.add(path__default.default.relative(cwd, touchedFile), cwd);
-    await git.commit(await getVersionMessage(releasePlan, commitOpts), cwd) ? logger.log("All files have been updated and committed. You're ready to publish!") : logger.error("Changesets ran into trouble committing your files");
+    for (;touchedFile = touchedFiles.shift(); ) await git__namespace.add(path__default.default.relative(cwd, touchedFile), cwd);
+    await git__namespace.commit(await getVersionMessage(releasePlan, commitOpts), cwd) ? logger.log("All files have been updated and committed. You're ready to publish!") : logger.error("Changesets ran into trouble committing your files");
   } else logger.log("All files have been updated. Review them and commit at your leisure");
 }
 
@@ -412,7 +441,7 @@ async function getTokenIsRequired() {
 
 function getPackageInfo(packageJson) {
   return npmRequestLimit((async () => {
-    logger.info("npm info " + packageJson.name);
+    logger.info(`npm info ${packageJson.name}`);
     let result = await spawn__default.default("npm", [ "info", packageJson.name, "--registry", getCorrectRegistry(packageJson), "--json" ]);
     return "" === result.stdout.toString() ? {
       error: {
@@ -425,7 +454,7 @@ function getPackageInfo(packageJson) {
 async function infoAllow404(packageJson) {
   var _pkgInfo$error;
   let pkgInfo = await getPackageInfo(packageJson);
-  if ("E404" === (null === (_pkgInfo$error = pkgInfo.error) || void 0 === _pkgInfo$error ? void 0 : _pkgInfo$error.code)) return logger.warn("Received 404 for npm info " + chalk__default.default.cyan(`"${packageJson.name}"`)), 
+  if ("E404" === (null === (_pkgInfo$error = pkgInfo.error) || void 0 === _pkgInfo$error ? void 0 : _pkgInfo$error.code)) return logger.warn(`Received 404 for npm info ${chalk__default.default.cyan(`"${packageJson.name}"`)}`), 
   {
     published: !1,
     pkgInfo: {}
@@ -461,7 +490,7 @@ async function internalPublish(pkgName, opts, twoFactorState) {
   });
   if (0 !== code) {
     let json = getLastJsonObjectFromString(stderr.toString()) || getLastJsonObjectFromString(stdout.toString());
-    if (null == json ? void 0 : json.error) {
+    if (null != json && json.error) {
       if (("EOTP" === json.error.code || "E401" === json.error.code && json.error.detail.includes("--otp=<code>")) && !isCI__default.default) return null !== twoFactorState.token && (twoFactorState.token = null), 
       twoFactorState.isRequired = Promise.resolve(!0), internalPublish(pkgName, opts, twoFactorState);
       logger.error(`an error occurred while publishing ${pkgName}: ${json.error.code}`, json.error.summary, json.error.detail ? "\n" + json.error.detail : "");
@@ -497,19 +526,41 @@ const isCustomRegistry = registry => !!registry && "https://registry.npmjs.org"
   isRequired: getTokenIsRequired()
 };
 
-async function publishPackages({packages: packages, access: access, otp: otp, preState: preState, tag: tag}) {
-  const packagesByName = new Map(packages.map((x => [ x.packageJson.name, x ]))), publicPackages = packages.filter((pkg => !pkg.packageJson.private)), twoFactorState = getTwoFactorState({
+async function publishPackages({packages: packages, access: access, otp: otp, preState: preState, tag: tag, tagPrivatePackages: tagPrivatePackages}) {
+  const packagesByName = new Map(packages.map((x => [ x.packageJson.name, x ]))), publicPackages = packages.filter((pkg => !pkg.packageJson.private)), privatePackages = packages.filter((pkg => pkg.packageJson.private && pkg.packageJson.version)), unpublishedPackagesInfo = await getUnpublishedPackages(publicPackages, preState), twoFactorState = unpublishedPackagesInfo.length > 0 ? getTwoFactorState({
     otp: otp,
     publicPackages: publicPackages
-  }), unpublishedPackagesInfo = await getUnpublishedPackages(publicPackages, preState);
-  return 0 === unpublishedPackagesInfo.length && logger.warn("No unpublished packages to publish"), 
-  Promise.all(unpublishedPackagesInfo.map((pkgInfo => publishAPackage(packagesByName.get(pkgInfo.name), access, twoFactorState, getReleaseTag(pkgInfo, preState, tag)))));
+  }) : {
+    token: null,
+    isRequired: Promise.resolve(!1)
+  }, npmPackagePublish = Promise.all(unpublishedPackagesInfo.map((pkgInfo => publishAPackage(packagesByName.get(pkgInfo.name), access, twoFactorState, getReleaseTag(pkgInfo, preState, tag))))), untaggedPrivatePackageReleases = tagPrivatePackages ? getUntaggedPrivatePackages(privatePackages) : Promise.resolve([]), result = {
+    publishedPackages: await npmPackagePublish,
+    untaggedPrivatePackages: await untaggedPrivatePackageReleases
+  };
+  return 0 === result.publishedPackages.length && 0 === result.untaggedPrivatePackages.length && logger.warn("No unpublished projects to publish"), 
+  result;
+}
+
+async function getUntaggedPrivatePackages(privatePackages) {
+  const packageWithTags = await Promise.all(privatePackages.map((async privatePkg => {
+    const tagName = `${privatePkg.packageJson.name}@${privatePkg.packageJson.version}`;
+    return {
+      pkg: privatePkg,
+      isMissingTag: !await git__namespace.remoteTagExists(tagName)
+    };
+  }))), untagged = [];
+  for (const packageWithTag of packageWithTags) packageWithTag.isMissingTag && untagged.push({
+    name: packageWithTag.pkg.packageJson.name,
+    newVersion: packageWithTag.pkg.packageJson.version,
+    published: !1
+  });
+  return untagged;
 }
 
 async function publishAPackage(pkg, access, twoFactorState, tag) {
   const {name: name, version: version, publishConfig: publishConfig} = pkg.packageJson, localAccess = null == publishConfig ? void 0 : publishConfig.access;
   logger.info(`Publishing ${chalk__default.default.cyan(`"${name}"`)} at ${chalk__default.default.green(`"${version}"`)}`);
-  const publishDir = (null == publishConfig ? void 0 : publishConfig.directory) ? path.join(pkg.dir, publishConfig.directory) : pkg.dir;
+  const publishDir = null != publishConfig && publishConfig.directory ? path.join(pkg.dir, publishConfig.directory) : pkg.dir;
   return {
     name: name,
     newVersion: version,
@@ -547,14 +598,14 @@ function logReleases(pkgs) {
   logger.log(mappedPkgs);
 }
 
-let importantSeparator$1 = chalk__default.default.red("===============================IMPORTANT!==============================="), importantEnd$1 = chalk__default.default.red("----------------------------------------------------------------------");
+let importantSeparator = chalk__default.default.red("===============================IMPORTANT!==============================="), importantEnd = chalk__default.default.red("----------------------------------------------------------------------");
 
 function showNonLatestTagWarning(tag, preState) {
-  logger.warn(importantSeparator$1), preState ? logger.warn(`You are in prerelease mode so packages will be published to the ${chalk__default.default.cyan(preState.tag)}\n        dist tag except for packages that have not had normal releases which will be published to ${chalk__default.default.cyan("latest")}`) : "latest" !== tag && logger.warn(`Packages will be released under the ${tag} tag`), 
-  logger.warn(importantEnd$1);
+  logger.warn(importantSeparator), preState ? logger.warn(`You are in prerelease mode so packages will be published to the ${chalk__default.default.cyan(preState.tag)}\n        dist tag except for packages that have not had normal releases which will be published to ${chalk__default.default.cyan("latest")}`) : "latest" !== tag && logger.warn(`Packages will be released under the ${tag} tag`), 
+  logger.warn(importantEnd);
 }
 
-async function run(cwd, {otp: otp, tag: tag, gitTag: gitTag = !0}, config) {
+async function run$2(cwd, {otp: otp, tag: tag, gitTag: gitTag = !0}, config) {
   const releaseTag = tag && tag.length > 0 ? tag : void 0;
   let preState = await pre$1.readPreState(cwd);
   if (releaseTag && preState && "pre" === preState.mode) throw logger.error("Releasing under custom tag is not allowed in pre mode"), 
@@ -566,26 +617,39 @@ async function run(cwd, {otp: otp, tag: tag, gitTag: gitTag = !0}, config) {
     access: config.access,
     otp: otp,
     preState: preState,
-    tag: releaseTag
-  }), successful = response.filter((p => p.published)), unsuccessful = response.filter((p => !p.published));
-  if (successful.length > 0 && (logger.success("packages published successfully:"), 
-  logReleases(successful), gitTag)) if (logger.log(`Creating git tag${successful.length > 1 ? "s" : ""}...`), 
-  "root" !== tool) for (const pkg of successful) {
+    tag: releaseTag,
+    tagPrivatePackages: isFlagEnabled(config.privatePackages, types.PrivatePackages.Tag)
+  }), successfulNpmPublishes = response.publishedPackages.filter((p => p.published)), unsuccessfulNpmPublishes = response.publishedPackages.filter((p => !p.published)), untaggedPrivatePackages = response.untaggedPrivatePackages;
+  if (successfulNpmPublishes.length > 0 && (logger.success("packages published successfully:"), 
+  logReleases(successfulNpmPublishes), gitTag)) if (logger.log(`Creating git tag${successfulNpmPublishes.length > 1 ? "s" : ""}...`), 
+  "root" !== tool) for (const pkg of successfulNpmPublishes) {
     const tag = `${pkg.name}@${pkg.newVersion}`;
-    logger.log("New tag: ", tag), await git.tag(tag, cwd);
+    logger.log("New tag: ", tag), await git__namespace.tag(tag, cwd);
   } else {
-    const tag = "v" + successful[0].newVersion;
-    logger.log("New tag: ", tag), await git.tag(tag, cwd);
+    const tag = `v${successfulNpmPublishes[0].newVersion}`;
+    logger.log("New tag: ", tag), await git__namespace.tag(tag, cwd);
   }
-  if (unsuccessful.length > 0) throw logger.error("packages failed to publish:"), 
-  logReleases(unsuccessful), new errors.ExitError(1);
+  if (untaggedPrivatePackages.length > 0) if (logger.success("found untagged projects:"), 
+  logReleases(untaggedPrivatePackages), "root" !== tool) for (const pkg of untaggedPrivatePackages) {
+    const tag = `${pkg.name}@${pkg.newVersion}`;
+    logger.log("New tag: ", tag), await git__namespace.tag(tag, cwd);
+  } else {
+    const tag = `v${untaggedPrivatePackages[0].newVersion}`;
+    logger.log("New tag: ", tag), await git__namespace.tag(tag, cwd);
+  }
+  if (unsuccessfulNpmPublishes.length > 0) throw logger.error("packages failed to publish:"), 
+  logReleases(unsuccessfulNpmPublishes), new errors.ExitError(1);
+}
+
+function isFlagEnabled(value, tag) {
+  return (value & tag) === tag;
 }
 
 async function getStatus(cwd, {sinceMaster: sinceMaster, since: since, verbose: verbose, output: output}, config) {
   sinceMaster && (logger.warn("--sinceMaster is deprecated and will be removed in a future major version"), 
   logger.warn("Use --since=master instead"));
   const sinceBranch = void 0 === since ? sinceMaster ? "master" : void 0 : since, releasePlan = await getReleasePlan__default.default(cwd, sinceBranch, config), {changesets: changesets, releases: releases} = releasePlan;
-  if ((await git.getChangedPackagesSinceRef({
+  if ((await git__namespace.getChangedPackagesSinceRef({
     cwd: cwd,
     ref: sinceBranch || config.baseBranch
   })).length > 0 && 0 === changesets.length && (logger.error("Some packages have been changed but no changesets were found. Run `changeset add` to resolve this error."), 
@@ -600,7 +664,7 @@ function SimplePrint(type, releases) {
   const packages = releases.filter((r => r.type === type));
   if (packages.length) {
     logger.info(chalk__default.default`Packages to be bumped at {green ${type}}:\n`);
-    const pkgs = packages.map((({name: name}) => "- " + name)).join("\n");
+    const pkgs = packages.map((({name: name}) => `- ${name}`)).join("\n");
     logger.log(chalk__default.default.green(pkgs));
   } else logger.info(chalk__default.default`{red NO} packages to be bumped at {green ${type}}`);
 }
@@ -609,7 +673,7 @@ function verbosePrint(type, releases) {
   const packages = releases.filter((r => r.type === type));
   if (packages.length) {
     logger.info(chalk__default.default`Packages to be bumped at {green ${type}}`);
-    const columns = packages.map((({name: name, newVersion: version, changesets: changesets}) => [ chalk__default.default.green(name), version, changesets.map((c => chalk__default.default.blue(` .changeset/${c}/changes.md`))).join(" +") ])), t1 = table__default.default([ {
+    const columns = packages.map((({name: name, newVersion: version, changesets: changesets}) => [ chalk__default.default.green(name), version, changesets.map((c => chalk__default.default.blue(` .changeset/${c}.md`))).join(" +") ])), t1 = table__default.default([ {
       value: "Package Name",
       width: 20
     }, {
@@ -630,31 +694,33 @@ function verbosePrint(type, releases) {
 
 async function pre(cwd, options) {
   if ("enter" === options.command) try {
-    await pre$1.enterPre(cwd, options.tag), logger.success("Entered pre mode with tag " + chalk__default.default.cyan(options.tag)), 
-    logger.info("Run `changeset version` to version packages with prerelease versions");
+    await pre$1.enterPre(cwd, options.tag), logger__namespace.success(`Entered pre mode with tag ${chalk__default.default.cyan(options.tag)}`), 
+    logger__namespace.info("Run `changeset version` to version packages with prerelease versions");
   } catch (err) {
-    if (err instanceof errors.PreEnterButInPreModeError) throw logger.error("`changeset pre enter` cannot be run when in pre mode"), 
-    logger.info("If you're trying to exit pre mode, run `changeset pre exit`"), new errors.ExitError(1);
+    if (err instanceof errors.PreEnterButInPreModeError) throw logger__namespace.error("`changeset pre enter` cannot be run when in pre mode"), 
+    logger__namespace.info("If you're trying to exit pre mode, run `changeset pre exit`"), 
+    new errors.ExitError(1);
     throw err;
   } else try {
-    await pre$1.exitPre(cwd), logger.success("Exited pre mode"), logger.info("Run `changeset version` to version packages with normal versions");
+    await pre$1.exitPre(cwd), logger__namespace.success("Exited pre mode"), logger__namespace.info("Run `changeset version` to version packages with normal versions");
   } catch (err) {
-    if (err instanceof errors.PreExitButNotInPreModeError) throw logger.error("`changeset pre exit` can only be run when in pre mode"), 
-    logger.info("If you're trying to enter pre mode, run `changeset pre enter`"), new errors.ExitError(1);
+    if (err instanceof errors.PreExitButNotInPreModeError) throw logger__namespace.error("`changeset pre exit` can only be run when in pre mode"), 
+    logger__namespace.info("If you're trying to enter pre mode, run `changeset pre enter`"), 
+    new errors.ExitError(1);
     throw err;
   }
 }
 
 async function run$1(cwd) {
-  const {packages: packages, tool: tool} = await getPackages.getPackages(cwd), allExistingTags = await git.getAllTags(cwd);
+  const {packages: packages, tool: tool} = await getPackages.getPackages(cwd), allExistingTags = await git__namespace.getAllTags(cwd);
   for (const pkg of packages) {
-    const tag = "root" !== tool ? `${pkg.packageJson.name}@${pkg.packageJson.version}` : "v" + pkg.packageJson.version;
+    const tag = "root" !== tool ? `${pkg.packageJson.name}@${pkg.packageJson.version}` : `v${pkg.packageJson.version}`;
     allExistingTags.has(tag) ? logger.log("Skipping tag (already exists): ", tag) : (logger.log("New tag: ", tag), 
-    await git.tag(tag, cwd));
+    await git__namespace.tag(tag, cwd));
   }
 }
 
-async function run$2(input, flags, cwd) {
+async function run(input, flags, cwd) {
   if ("init" === input[0]) return void await init(cwd);
   if (!fs__default.default.existsSync(path__default.default.resolve(cwd, ".changeset"))) throw logger.error("There is no .changeset folder. "), 
   logger.error("If this is the first time `changesets` have been used in this project, run `yarn changeset init` to get set up."), 
@@ -711,7 +777,7 @@ async function run$2(input, flags, cwd) {
       }
 
      case "publish":
-      return void await run(cwd, {
+      return void await run$2(cwd, {
         otp: otp,
         tag: tag,
         gitTag: gitTag
@@ -797,7 +863,7 @@ const {input: input, flags: flags} = meow__default.default("\n  Usage\n    $ cha
   }
 }), cwd = process.cwd();
 
-run$2(input, flags, cwd).catch((err => {
+run(input, flags, cwd).catch((err => {
   if (err instanceof errors.InternalError && (logger.error("The following error is an internal unexpected error, these should never happen."), 
   logger.error("Please open an issue with the following link"), logger.error(`https://github.com/changesets/changesets/issues/new?title=${encodeURIComponent(`Unexpected error during ${input[0] || "add"} command`)}&body=${encodeURIComponent(`## Error\n\n\`\`\`\n${util.format("", err).replace(process.cwd(), "<cwd>")}\n\`\`\`\n\n## Versions\n\n- @changesets/cli@${require("@changesets/cli/package.json").version}\n- node@${process.version}\n\n## Extra details\n\n\x3c!-- Add any extra details of what you were doing, ideas you have about what might have caused the error and reproduction steps if possible. If you have a repository we can look at that would be great. 😁 --\x3e\n`)}`)), 
   err instanceof errors.ExitError) return process.exit(err.code);
diff --git a/node_modules/@changesets/cli/dist/cli.esm.js b/node_modules/@changesets/cli/dist/cli.esm.js
index 910b72c..de6cf6c 100644
--- a/node_modules/@changesets/cli/dist/cli.esm.js
+++ b/node_modules/@changesets/cli/dist/cli.esm.js
@@ -1,5 +1,6 @@
 import meow from 'meow';
 import { ExitError, PreEnterButInPreModeError, PreExitButNotInPreModeError, InternalError } from '@changesets/errors';
+import * as logger from '@changesets/logger';
 import { error, info, warn, log, prefix, success } from '@changesets/logger';
 import { format } from 'util';
 import fs from 'fs-extra';
@@ -13,7 +14,8 @@ import termSize from 'term-size';
 import { prompt } from 'enquirer';
 import { edit, ExternalEditor } from 'external-editor';
 import { symbols } from 'ansi-colors';
-import { getChangedPackagesSinceRef, add as add$1, commit, tag, getAllTags } from '@changesets/git';
+import * as git from '@changesets/git';
+import { PrivatePackages } from '@changesets/types';
 import writeChangeset from '@changesets/write';
 import resolveFrom from 'resolve-from';
 import semver from 'semver';
@@ -49,10 +51,9 @@ function ownKeys(object, enumerableOnly) {
 
   if (Object.getOwnPropertySymbols) {
     var symbols = Object.getOwnPropertySymbols(object);
-    if (enumerableOnly) symbols = symbols.filter(function (sym) {
+    enumerableOnly && (symbols = symbols.filter(function (sym) {
       return Object.getOwnPropertyDescriptor(object, sym).enumerable;
-    });
-    keys.push.apply(keys, symbols);
+    })), keys.push.apply(keys, symbols);
   }
 
   return keys;
@@ -60,19 +61,12 @@ function ownKeys(object, enumerableOnly) {
 
 function _objectSpread2(target) {
   for (var i = 1; i < arguments.length; i++) {
-    var source = arguments[i] != null ? arguments[i] : {};
-
-    if (i % 2) {
-      ownKeys(Object(source), true).forEach(function (key) {
-        _defineProperty(target, key, source[key]);
-      });
-    } else if (Object.getOwnPropertyDescriptors) {
-      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
-    } else {
-      ownKeys(Object(source)).forEach(function (key) {
-        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
-      });
-    }
+    var source = null != arguments[i] ? arguments[i] : {};
+    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
+      _defineProperty(target, key, source[key]);
+    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
+      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
+    });
   }
 
   return target;
@@ -255,7 +249,7 @@ async function confirmMajorRelease(pkgJSON) {
   return true;
 }
 
-async function getPackagesToRelease(changedPackages, allPackages) {
+async function getPackagesToRelease(changedPackages, allPackages, ignorePrivatePackages) {
   function askInitialReleaseQuestion(defaultChoiceList) {
     return askCheckboxPlus( // TODO: Make this wording better
     // TODO: take objects and be fancy with matching
@@ -270,6 +264,11 @@ async function getPackagesToRelease(changedPackages, allPackages) {
     });
   }
 
+  const pkgJsonsByName = getPkgJsonsByName(allPackages); // filter out packages which changesets is not tracking
+
+  allPackages = allPackages.filter(pkg => isValidChangesetPackage(pkg.packageJson, ignorePrivatePackages));
+  changedPackages = changedPackages.filter(pkgName => !isValidChangesetPackage(pkgJsonsByName.get(pkgName), ignorePrivatePackages));
+
   if (allPackages.length > 1) {
     const unchangedPackagesNames = allPackages.map(({
       packageJson
@@ -299,18 +298,32 @@ async function getPackagesToRelease(changedPackages, allPackages) {
   return [allPackages[0].packageJson.name];
 }
 
+function getPkgJsonsByName(packages) {
+  return new Map(packages.map(({
+    packageJson
+  }) => [packageJson.name, packageJson]));
+}
+
+function isValidChangesetPackage(packageJson, ignorePrivatePackages) {
+  const hasVersionField = !!packageJson.version;
+
+  if (ignorePrivatePackages && packageJson.private) {
+    return false;
+  }
+
+  return hasVersionField;
+}
+
 function formatPkgNameAndVersion(pkgName, version) {
   return `${bold(pkgName)}@${bold(version)}`;
 }
 
-async function createChangeset(changedPackages, allPackages) {
+async function createChangeset(changedPackages, allPackages, ignorePrivatePackages) {
   const releases = [];
 
   if (allPackages.length > 1) {
-    const packagesToRelease = await getPackagesToRelease(changedPackages, allPackages);
-    let pkgJsonsByName = new Map(allPackages.map(({
-      packageJson
-    }) => [packageJson.name, packageJson]));
+    const packagesToRelease = await getPackagesToRelease(changedPackages, allPackages, ignorePrivatePackages);
+    let pkgJsonsByName = getPkgJsonsByName(allPackages);
     let pkgsLeftToGetBumpTypeFor = new Set(packagesToRelease);
     let pkgsThatShouldBeMajorBumped = (await askCheckboxPlus(bold(`Which packages should have a ${red("major")} bump?`), [{
       name: "all packages",
@@ -476,12 +489,12 @@ async function add(cwd, {
       summary: ``
     };
   } else {
-    const changedPackages = await getChangedPackagesSinceRef({
+    const changedPackages = await git.getChangedPackagesSinceRef({
       cwd,
       ref: config.baseBranch
     });
     const changePackagesName = changedPackages.filter(a => a).map(pkg => pkg.packageJson.name);
-    newChangeset = await createChangeset(changePackagesName, packages.packages);
+    newChangeset = await createChangeset(changePackagesName, packages.packages, config.privatePackages === PrivatePackages.Ignore);
     printConfirmationMessage(newChangeset, packages.packages.length > 1);
 
     if (!newChangeset.confirmed) {
@@ -498,8 +511,8 @@ async function add(cwd, {
     }, commitOpts] = getCommitFunctions(config.commit, cwd);
 
     if (getAddMessage) {
-      await add$1(path.resolve(changesetBase, `${changesetID}.md`), cwd);
-      await commit(await getAddMessage(newChangeset, commitOpts), cwd);
+      await git.add(path.resolve(changesetBase, `${changesetID}.md`), cwd);
+      await git.commit(await getAddMessage(newChangeset, commitOpts), cwd);
       log(chalk.green(`${empty ? "Empty " : ""}Changeset added and committed`));
     } else {
       log(chalk.green(`${empty ? "Empty " : ""}Changeset added! - you can now commit it\n`));
@@ -551,8 +564,8 @@ const removeEmptyFolders = async folderPath => {
   }));
 };
 
-let importantSeparator = chalk.red("===============================IMPORTANT!===============================");
-let importantEnd = chalk.red("----------------------------------------------------------------------");
+let importantSeparator$1 = chalk.red("===============================IMPORTANT!===============================");
+let importantEnd$1 = chalk.red("----------------------------------------------------------------------");
 async function version(cwd, options, config) {
   const releaseConfig = _objectSpread2(_objectSpread2({}, config), {}, {
     // Disable committing when in snapshot mode
@@ -562,7 +575,7 @@ async function version(cwd, options, config) {
   const [changesets, preState] = await Promise.all([readChangesets(cwd), readPreState(cwd), removeEmptyFolders(path.resolve(cwd, ".changeset"))]);
 
   if ((preState === null || preState === void 0 ? void 0 : preState.mode) === "pre") {
-    warn(importantSeparator);
+    warn(importantSeparator$1);
 
     if (options.snapshot !== undefined) {
       error("Snapshot release is not allowed in pre mode");
@@ -574,7 +587,7 @@ async function version(cwd, options, config) {
       warn("You can then run `changeset version` again to do a normal release");
     }
 
-    warn(importantEnd);
+    warn(importantEnd$1);
   }
 
   if (changesets.length === 0 && (preState === undefined || preState.mode !== "exit")) {
@@ -594,12 +607,12 @@ async function version(cwd, options, config) {
     // So we need to be careful that these iterations are properly sequential
 
     while (touchedFile = touchedFiles.shift()) {
-      await add$1(path.relative(cwd, touchedFile), cwd);
+      await git.add(path.relative(cwd, touchedFile), cwd);
     }
 
-    const commit$1 = await commit(await getVersionMessage(releasePlan, commitOpts), cwd);
+    const commit = await git.commit(await getVersionMessage(releasePlan, commitOpts), cwd);
 
-    if (!commit$1) {
+    if (!commit) {
       error("Changesets ran into trouble committing your files");
     } else {
       log("All files have been updated and committed. You're ready to publish!");
@@ -797,7 +810,7 @@ async function internalPublish(pkgName, opts, twoFactorState) {
     // Note that the `--json` output is always printed at the end so this should work
     let json = getLastJsonObjectFromString(stderr.toString()) || getLastJsonObjectFromString(stdout.toString());
 
-    if (json === null || json === void 0 ? void 0 : json.error) {
+    if (json !== null && json !== void 0 && json.error) {
       // The first case is no 2fa provided, the second is when the 2fa is wrong (timeout or wrong words)
       if ((json.error.code === "EOTP" || json.error.code === "E401" && json.error.detail.includes("--otp=<code>")) && !isCI) {
         if (twoFactorState.token !== null) {
@@ -876,24 +889,59 @@ async function publishPackages({
   access,
   otp,
   preState,
-  tag
+  tag,
+  tagPrivatePackages
 }) {
   const packagesByName = new Map(packages.map(x => [x.packageJson.name, x]));
   const publicPackages = packages.filter(pkg => !pkg.packageJson.private);
-  const twoFactorState = getTwoFactorState({
+  const privatePackages = packages.filter(pkg => pkg.packageJson.private && pkg.packageJson.version);
+  const unpublishedPackagesInfo = await getUnpublishedPackages(publicPackages, preState);
+  const twoFactorState = unpublishedPackagesInfo.length > 0 ? getTwoFactorState({
     otp,
     publicPackages
-  });
-  const unpublishedPackagesInfo = await getUnpublishedPackages(publicPackages, preState);
+  }) : {
+    token: null,
+    isRequired: Promise.resolve(false)
+  };
+  const npmPackagePublish = Promise.all(unpublishedPackagesInfo.map(pkgInfo => {
+    let pkg = packagesByName.get(pkgInfo.name);
+    return publishAPackage(pkg, access, twoFactorState, getReleaseTag(pkgInfo, preState, tag));
+  }));
+  const untaggedPrivatePackageReleases = tagPrivatePackages ? getUntaggedPrivatePackages(privatePackages) : Promise.resolve([]);
+  const result = {
+    publishedPackages: await npmPackagePublish,
+    untaggedPrivatePackages: await untaggedPrivatePackageReleases
+  };
 
-  if (unpublishedPackagesInfo.length === 0) {
-    warn("No unpublished packages to publish");
+  if (result.publishedPackages.length === 0 && result.untaggedPrivatePackages.length === 0) {
+    warn("No unpublished projects to publish");
   }
 
-  return Promise.all(unpublishedPackagesInfo.map(pkgInfo => {
-    let pkg = packagesByName.get(pkgInfo.name);
-    return publishAPackage(pkg, access, twoFactorState, getReleaseTag(pkgInfo, preState, tag));
+  return result;
+}
+
+async function getUntaggedPrivatePackages(privatePackages) {
+  const packageWithTags = await Promise.all(privatePackages.map(async privatePkg => {
+    const tagName = `${privatePkg.packageJson.name}@${privatePkg.packageJson.version}`;
+    const isMissingTag = !(await git.remoteTagExists(tagName));
+    return {
+      pkg: privatePkg,
+      isMissingTag
+    };
   }));
+  const untagged = [];
+
+  for (const packageWithTag of packageWithTags) {
+    if (packageWithTag.isMissingTag) {
+      untagged.push({
+        name: packageWithTag.pkg.packageJson.name,
+        newVersion: packageWithTag.pkg.packageJson.version,
+        published: false
+      });
+    }
+  }
+
+  return untagged;
 }
 
 async function publishAPackage(pkg, access, twoFactorState, tag) {
@@ -904,7 +952,7 @@ async function publishAPackage(pkg, access, twoFactorState, tag) {
   } = pkg.packageJson;
   const localAccess = publishConfig === null || publishConfig === void 0 ? void 0 : publishConfig.access;
   info(`Publishing ${chalk.cyan(`"${name}"`)} at ${chalk.green(`"${version}"`)}`);
-  const publishDir = (publishConfig === null || publishConfig === void 0 ? void 0 : publishConfig.directory) ? join(pkg.dir, publishConfig.directory) : pkg.dir;
+  const publishDir = publishConfig !== null && publishConfig !== void 0 && publishConfig.directory ? join(pkg.dir, publishConfig.directory) : pkg.dir;
   const publishConfirmation = await publish(name, {
     cwd: publishDir,
     access: localAccess || access,
@@ -972,11 +1020,11 @@ function logReleases(pkgs) {
   log(mappedPkgs);
 }
 
-let importantSeparator$1 = chalk.red("===============================IMPORTANT!===============================");
-let importantEnd$1 = chalk.red("----------------------------------------------------------------------");
+let importantSeparator = chalk.red("===============================IMPORTANT!===============================");
+let importantEnd = chalk.red("----------------------------------------------------------------------");
 
 function showNonLatestTagWarning(tag, preState) {
-  warn(importantSeparator$1);
+  warn(importantSeparator);
 
   if (preState) {
     warn(`You are in prerelease mode so packages will be published to the ${chalk.cyan(preState.tag)}
@@ -985,15 +1033,15 @@ function showNonLatestTagWarning(tag, preState) {
     warn(`Packages will be released under the ${tag} tag`);
   }
 
-  warn(importantEnd$1);
+  warn(importantEnd);
 }
 
-async function run(cwd, {
+async function run$2(cwd, {
   otp,
-  tag: tag$1,
+  tag,
   gitTag = true
 }, config) {
-  const releaseTag = tag$1 && tag$1.length > 0 ? tag$1 : undefined;
+  const releaseTag = tag && tag.length > 0 ? tag : undefined;
   let preState = await readPreState(cwd);
 
   if (releaseTag && preState && preState.mode === "pre") {
@@ -1003,7 +1051,7 @@ async function run(cwd, {
   }
 
   if (releaseTag || preState) {
-    showNonLatestTagWarning(tag$1, preState);
+    showNonLatestTagWarning(tag, preState);
   }
 
   const {
@@ -1016,42 +1064,65 @@ async function run(cwd, {
     access: config.access,
     otp,
     preState,
-    tag: releaseTag
+    tag: releaseTag,
+    tagPrivatePackages: isFlagEnabled(config.privatePackages, PrivatePackages.Tag)
   });
-  const successful = response.filter(p => p.published);
-  const unsuccessful = response.filter(p => !p.published);
+  const successfulNpmPublishes = response.publishedPackages.filter(p => p.published);
+  const unsuccessfulNpmPublishes = response.publishedPackages.filter(p => !p.published);
+  const untaggedPrivatePackages = response.untaggedPrivatePackages;
 
-  if (successful.length > 0) {
+  if (successfulNpmPublishes.length > 0) {
     success("packages published successfully:");
-    logReleases(successful);
+    logReleases(successfulNpmPublishes);
 
     if (gitTag) {
       // We create the tags after the push above so that we know that HEAD won't change and that pushing
       // won't suffer from a race condition if another merge happens in the mean time (pushing tags won't
       // fail if we are behind the base branch).
-      log(`Creating git tag${successful.length > 1 ? "s" : ""}...`);
+      log(`Creating git tag${successfulNpmPublishes.length > 1 ? "s" : ""}...`);
 
       if (tool !== "root") {
-        for (const pkg of successful) {
-          const tag$1 = `${pkg.name}@${pkg.newVersion}`;
-          log("New tag: ", tag$1);
-          await tag(tag$1, cwd);
+        for (const pkg of successfulNpmPublishes) {
+          const tag = `${pkg.name}@${pkg.newVersion}`;
+          log("New tag: ", tag);
+          await git.tag(tag, cwd);
         }
       } else {
-        const tag$1 = `v${successful[0].newVersion}`;
-        log("New tag: ", tag$1);
-        await tag(tag$1, cwd);
+        const tag = `v${successfulNpmPublishes[0].newVersion}`;
+        log("New tag: ", tag);
+        await git.tag(tag, cwd);
       }
     }
   }
 
-  if (unsuccessful.length > 0) {
+  if (untaggedPrivatePackages.length > 0) {
+    success("found untagged projects:");
+    logReleases(untaggedPrivatePackages);
+
+    if (tool !== "root") {
+      for (const pkg of untaggedPrivatePackages) {
+        const tag = `${pkg.name}@${pkg.newVersion}`;
+        log("New tag: ", tag);
+        await git.tag(tag, cwd);
+      }
+    } else {
+      const tag = `v${untaggedPrivatePackages[0].newVersion}`;
+      log("New tag: ", tag);
+      await git.tag(tag, cwd);
+    }
+  }
+
+  if (unsuccessfulNpmPublishes.length > 0) {
     error("packages failed to publish:");
-    logReleases(unsuccessful);
+    logReleases(unsuccessfulNpmPublishes);
     throw new ExitError(1);
   }
 }
 
+function isFlagEnabled(value, tag) {
+  return (value & tag) === tag;
+}
+
 async function getStatus(cwd, {
   sinceMaster,
   since,
@@ -1069,7 +1140,7 @@ async function getStatus(cwd, {
     changesets,
     releases
   } = releasePlan;
-  const changedPackages = await getChangedPackagesSinceRef({
+  const changedPackages = await git.getChangedPackagesSinceRef({
     cwd,
     ref: sinceBranch || config.baseBranch
   });
@@ -1117,7 +1188,7 @@ function verbosePrint(type, releases) {
       name,
       newVersion: version,
       changesets
-    }) => [chalk.green(name), version, changesets.map(c => chalk.blue(` .changeset/${c}/changes.md`)).join(" +")]);
+    }) => [chalk.green(name), version, changesets.map(c => chalk.blue(` .changeset/${c}.md`)).join(" +")]);
     const t1 = table([{
       value: "Package Name",
       width: 20
@@ -1143,12 +1214,12 @@ async function pre(cwd, options) {
   if (options.command === "enter") {
     try {
       await enterPre(cwd, options.tag);
-      success(`Entered pre mode with tag ${chalk.cyan(options.tag)}`);
-      info("Run `changeset version` to version packages with prerelease versions");
+      logger.success(`Entered pre mode with tag ${chalk.cyan(options.tag)}`);
+      logger.info("Run `changeset version` to version packages with prerelease versions");
     } catch (err) {
       if (err instanceof PreEnterButInPreModeError) {
-        error("`changeset pre enter` cannot be run when in pre mode");
-        info("If you're trying to exit pre mode, run `changeset pre exit`");
+        logger.error("`changeset pre enter` cannot be run when in pre mode");
+        logger.info("If you're trying to exit pre mode, run `changeset pre exit`");
         throw new ExitError(1);
       }
 
@@ -1157,12 +1228,12 @@ async function pre(cwd, options) {
   } else {
     try {
       await exitPre(cwd);
-      success(`Exited pre mode`);
-      info("Run `changeset version` to version packages with normal versions");
+      logger.success(`Exited pre mode`);
+      logger.info("Run `changeset version` to version packages with normal versions");
     } catch (err) {
       if (err instanceof PreExitButNotInPreModeError) {
-        error("`changeset pre exit` can only be run when in pre mode");
-        info("If you're trying to enter pre mode, run `changeset pre enter`");
+        logger.error("`changeset pre exit` can only be run when in pre mode");
+        logger.info("If you're trying to enter pre mode, run `changeset pre enter`");
         throw new ExitError(1);
       }
 
@@ -1176,21 +1247,21 @@ async function run$1(cwd) {
     packages,
     tool
   } = await getPackages(cwd);
-  const allExistingTags = await getAllTags(cwd);
+  const allExistingTags = await git.getAllTags(cwd);
 
   for (const pkg of packages) {
-    const tag$1 = tool !== "root" ? `${pkg.packageJson.name}@${pkg.packageJson.version}` : `v${pkg.packageJson.version}`;
+    const tag = tool !== "root" ? `${pkg.packageJson.name}@${pkg.packageJson.version}` : `v${pkg.packageJson.version}`;
 
-    if (allExistingTags.has(tag$1)) {
-      log("Skipping tag (already exists): ", tag$1);
+    if (allExistingTags.has(tag)) {
+      log("Skipping tag (already exists): ", tag);
     } else {
-      log("New tag: ", tag$1);
-      await tag(tag$1, cwd);
+      log("New tag: ", tag);
+      await git.tag(tag, cwd);
     }
   }
 }
 
-async function run$2(input, flags, cwd) {
+async function run(input, flags, cwd) {
   if (input[0] === "init") {
     await init(cwd);
     return;
@@ -1329,7 +1400,7 @@ async function run$2(input, flags, cwd) {
 
       case "publish":
         {
-          await run(cwd, {
+          await run$2(cwd, {
             otp,
             tag,
             gitTag
@@ -1457,7 +1528,7 @@ const {
   }
 });
 const cwd = process.cwd();
-run$2(input, flags, cwd).catch(err => {
+run(input, flags, cwd).catch(err => {
   if (err instanceof InternalError) {
     error("The following error is an internal unexpected error, these should never happen.");
     error("Please open an issue with the following link");
diff --git a/node_modules/@changesets/cli/dist/declarations/src/commands/add/createChangeset.d.ts b/node_modules/@changesets/cli/dist/declarations/src/commands/add/createChangeset.d.ts
index 0dd1f7d..e2dd780 100644
--- a/node_modules/@changesets/cli/dist/declarations/src/commands/add/createChangeset.d.ts
+++ b/node_modules/@changesets/cli/dist/declarations/src/commands/add/createChangeset.d.ts
@@ -1,6 +1,6 @@
 import { Release } from "@changesets/types";
 import { Package } from "@manypkg/get-packages";
-export default function createChangeset(changedPackages: Array<string>, allPackages: Package[]): Promise<{
+export default function createChangeset(changedPackages: Array<string>, allPackages: Package[], ignorePrivatePackages: boolean): Promise<{
     confirmed: boolean;
     summary: string;
     releases: Array<Release>;
diff --git a/node_modules/@changesets/cli/dist/declarations/src/commands/publish/publishPackages.d.ts b/node_modules/@changesets/cli/dist/declarations/src/commands/publish/publishPackages.d.ts
index b2a9563..8df2399 100644
--- a/node_modules/@changesets/cli/dist/declarations/src/commands/publish/publishPackages.d.ts
+++ b/node_modules/@changesets/cli/dist/declarations/src/commands/publish/publishPackages.d.ts
@@ -6,11 +6,15 @@ declare type PublishedResult = {
     newVersion: string;
     published: boolean;
 };
-export default function publishPackages({ packages, access, otp, preState, tag }: {
+export default function publishPackages({ packages, access, otp, preState, tag, tagPrivatePackages }: {
     packages: Package[];
     access: AccessType;
     otp?: string;
     preState: PreState | undefined;
     tag?: string;
-}): Promise<PublishedResult[]>;
+    tagPrivatePackages: boolean;
+}): Promise<{
+    publishedPackages: PublishedResult[];
+    untaggedPrivatePackages: Omit<PublishedResult, "published">[];
+}>;
 export {};
diff --git a/node_modules/@changesets/cli/src/changelog.ts b/node_modules/@changesets/cli/src/changelog.ts
new file mode 100644
index 0000000..0a80c80
--- /dev/null
+++ b/node_modules/@changesets/cli/src/changelog.ts
@@ -0,0 +1 @@
+export { default } from "@changesets/changelog-git";
diff --git a/node_modules/@changesets/cli/src/commands/add/__tests__/add.ts b/node_modules/@changesets/cli/src/commands/add/__tests__/add.ts
new file mode 100644
index 0000000..25f4934
--- /dev/null
+++ b/node_modules/@changesets/cli/src/commands/add/__tests__/add.ts
@@ -0,0 +1,207 @@
+import path from "path";
+import fixtures from "fixturez";
+import stripAnsi from "strip-ansi";
+import * as git from "@changesets/git";
+import { defaultConfig } from "@changesets/config";
+import { silenceLogsInBlock } from "@changesets/test-utils";
+import writeChangeset from "@changesets/write";
+
+import {
+  askCheckboxPlus,
+  askConfirm,
+  askQuestionWithEditor,
+  askQuestion,
+  askList
+} from "../../../utils/cli-utilities";
+import addChangeset from "..";
+
+const f = fixtures(__dirname);
+
+jest.mock("../../../utils/cli-utilities");
+jest.mock("@changesets/git");
+jest.mock("@changesets/write");
+// @ts-ignore
+writeChangeset.mockImplementation(() => Promise.resolve("abcdefg"));
+// @ts-ignore
+git.commit.mockImplementation(() => Promise.resolve(true));
+
+// @ts-ignore
+git.getChangedPackagesSinceRef.mockImplementation(({ ref }) => {
+  expect(ref).toBe("master");
+  return [];
+});
+
+// @ts-ignore
+const mockUserResponses = mockResponses => {
+  const summary = mockResponses.summary || "summary message mock";
+  let majorReleases: Array<string> = [];
+  let minorReleases: Array<string> = [];
+  Object.entries(mockResponses.releases).forEach(([pkgName, type]) => {
+    if (type === "major") {
+      majorReleases.push(pkgName);
+    } else if (type === "minor") {
+      minorReleases.push(pkgName);
+    }
+  });
+  let callCount = 0;
+  let returnValues = [
+    Object.keys(mockResponses.releases),
+    majorReleases,
+    minorReleases
+  ];
+  // @ts-ignore
+  askCheckboxPlus.mockImplementation(() => {
+    if (callCount === returnValues.length) {
+      throw new Error(`There was an unexpected call to askCheckboxPlus`);
+    }
+    return returnValues[callCount++];
+  });
+
+  let confirmAnswers = {
+    "Is this your desired changeset?": true
+  };
+
+  if (mockResponses.consoleSummaries && mockResponses.editorSummaries) {
+    let i = 0;
+    let j = 0;
+    // @ts-ignore
+    askQuestion.mockImplementation(() => mockResponses.consoleSummaries[i++]);
+    // @ts-ignore
+    askQuestionWithEditor.mockImplementation(
+      () => mockResponses.editorSummaries[j++]
+    );
+  } else {
+    // @ts-ignore
+    askQuestion.mockReturnValueOnce(summary);
+  }
+
+  // @ts-ignore
+  askConfirm.mockImplementation(question => {
+    question = stripAnsi(question);
+    // @ts-ignore
+    if (confirmAnswers[question]) {
+      // @ts-ignore
+      return confirmAnswers[question];
+    }
+    throw new Error(`An answer could not be found for ${question}`);
+  });
+};
+
+describe("Changesets", () => {
+  silenceLogsInBlock();
+
+  it("should generate changeset to patch a single package", async () => {
+    const cwd = await f.copy("simple-project");
+
+    mockUserResponses({ releases: { "pkg-a": "patch" } });
+    await addChangeset(cwd, { empty: false }, defaultConfig);
+
+    // @ts-ignore
+    const call = writeChangeset.mock.calls[0][0];
+    expect(call).toEqual(
+      expect.objectContaining({
+        summary: "summary message mock",
+        releases: [{ name: "pkg-a", type: "patch" }]
+      })
+    );
+  });
+
+  it.each`
+    consoleSummaries                          | editorSummaries                           | expectedSummary
+    ${["summary on step 1"]}                  | ${[]}                                     | ${"summary on step 1"}
+    ${[""]}                                   | ${["summary in external editor"]}         | ${"summary in external editor"}
+    ${["", "summary after editor cancelled"]} | ${[""]}                                   | ${"summary after editor cancelled"}
+    ${["", "summary after error"]}            | ${1 /* mock implementation will throw */} | ${"summary after error"}
+  `(
+    "should read summary",
+    // @ts-ignore
+    async ({ consoleSummaries, editorSummaries, expectedSummary }) => {
+      const cwd = await f.copy("simple-project");
+
+      mockUserResponses({
+        releases: { "pkg-a": "patch" },
+        consoleSummaries,
+        editorSummaries
+      });
+      await addChangeset(cwd, { empty: false }, defaultConfig);
+
+      // @ts-ignore
+      const call = writeChangeset.mock.calls[0][0];
+      expect(call).toEqual(
+        expect.objectContaining({
+          summary: expectedSummary,
+          releases: [{ name: "pkg-a", type: "patch" }]
+        })
+      );
+    }
+  );
+
+  it("should generate a changeset in a single package repo", async () => {
+    const cwd = await f.copy("single-package");
+
+    const summary = "summary message mock";
+
+    // @ts-ignore
+    askList.mockReturnValueOnce(Promise.resolve("minor"));
+
+    let confirmAnswers = {
+      "Is this your desired changeset?": true
+    };
+    // @ts-ignore
+    askQuestion.mockReturnValueOnce("");
+    // @ts-ignore
+    askQuestionWithEditor.mockReturnValueOnce(summary);
+    // @ts-ignore
+    askConfirm.mockImplementation(question => {
+      question = stripAnsi(question);
+      // @ts-ignore
+      if (confirmAnswers[question]) {
+        // @ts-ignore
+        return confirmAnswers[question];
+      }
+      throw new Error(`An answer could not be found for ${question}`);
+    });
+
+    await addChangeset(cwd, { empty: false }, defaultConfig);
+
+    // @ts-ignore
+    const call = writeChangeset.mock.calls[0][0];
+    expect(call).toEqual(
+      expect.objectContaining({
+        summary: "summary message mock",
+        releases: [{ name: "single-package", type: "minor" }]
+      })
+    );
+  });
+
+  it("should commit when the commit flag is passed in", async () => {
+    const cwd = await f.copy("simple-project-custom-config");
+
+    mockUserResponses({ releases: { "pkg-a": "patch" } });
+    await addChangeset(
+      cwd,
+      { empty: false },
+      {
+        ...defaultConfig,
+        commit: [path.resolve(__dirname, "..", "..", "..", "commit"), null]
+      }
+    );
+    expect(git.add).toHaveBeenCalledTimes(1);
+    expect(git.commit).toHaveBeenCalledTimes(1);
+  });
+
+  it("should create empty changeset when empty flag is passed in", async () => {
+    const cwd = await f.copy("simple-project");
+
+    await addChangeset(cwd, { empty: true }, defaultConfig);
+
+    // @ts-ignore
+    const call = writeChangeset.mock.calls[0][0];
+    expect(call).toEqual(
+      expect.objectContaining({
+        releases: [],
+        summary: ""
+      })
+    );
+  });
+});
diff --git a/node_modules/@changesets/cli/src/commands/add/createChangeset.ts b/node_modules/@changesets/cli/src/commands/add/createChangeset.ts
new file mode 100644
index 0000000..55b53a9
--- /dev/null
+++ b/node_modules/@changesets/cli/src/commands/add/createChangeset.ts
@@ -0,0 +1,301 @@
+import chalk from "chalk";
+
+import semver from "semver";
+
+import * as cli from "../../utils/cli-utilities";
+import { error, log } from "@changesets/logger";
+import { Release, PackageJSON } from "@changesets/types";
+import { Package } from "@manypkg/get-packages";
+import { ExitError } from "@changesets/errors";
+
+const { green, yellow, red, bold, blue, cyan } = chalk;
+
+async function confirmMajorRelease(pkgJSON: PackageJSON) {
+  if (semver.lt(pkgJSON.version, "1.0.0")) {
+    // prettier-ignore
+    log(yellow(`WARNING: Releasing a major version for ${green(pkgJSON.name)} will be its ${red('first major release')}.`))
+    log(
+      yellow(
+        `If you are unsure if this is correct, contact the package's maintainers ${red(
+          "before committing this changeset"
+        )}.`
+      )
+    );
+
+    let shouldReleaseFirstMajor = await cli.askConfirm(
+      bold(
+        `Are you sure you want to release the ${red(
+          "first major version"
+        )} of ${pkgJSON.name}?`
+      )
+    );
+    return shouldReleaseFirstMajor;
+  }
+  return true;
+}
+
+async function getPackagesToRelease(
+  changedPackages: Array<string>,
+  allPackages: Array<Package>,
+  ignorePrivatePackages: boolean
+) {
+  function askInitialReleaseQuestion(defaultChoiceList: Array<any>) {
+    return cli.askCheckboxPlus(
+      // TODO: Make this wording better
+      // TODO: take objects and be fancy with matching
+      `Which packages would you like to include?`,
+      defaultChoiceList,
+      x => {
+        // this removes changed packages and unchanged packages from the list
+        // of packages shown after selection
+        if (Array.isArray(x)) {
+          return x
+            .filter(x => x !== "changed packages" && x !== "unchanged packages")
+            .map(x => cyan(x))
+            .join(", ");
+        }
+        return x;
+      }
+    );
+  }
+
+  const pkgJsonsByName = getPkgJsonsByName(allPackages);
+
+  // filter out packages which changesets is not tracking
+  allPackages = allPackages.filter(pkg =>
+    isValidChangesetPackage(pkg.packageJson, ignorePrivatePackages)
+  );
+  changedPackages = changedPackages.filter(
+    pkgName =>
+      !isValidChangesetPackage(
+        pkgJsonsByName.get(pkgName)!,
+        ignorePrivatePackages
+      )
+  );
+
+  if (allPackages.length > 1) {
+    const unchangedPackagesNames = allPackages
+      .map(({ packageJson }) => packageJson.name)
+      .filter(name => !changedPackages.includes(name));
+
+    const defaultChoiceList = [
+      {
+        name: "changed packages",
+        choices: changedPackages
+      },
+      {
+        name: "unchanged packages",
+        choices: unchangedPackagesNames
+      }
+    ].filter(({ choices }) => choices.length !== 0);
+
+    let packagesToRelease = await askInitialReleaseQuestion(defaultChoiceList);
+
+    if (packagesToRelease.length === 0) {
+      do {
+        error("You must select at least one package to release");
+        error("(You most likely hit enter instead of space!)");
+
+        packagesToRelease = await askInitialReleaseQuestion(defaultChoiceList);
+      } while (packagesToRelease.length === 0);
+    }
+    return packagesToRelease.filter(
+      pkgName =>
+        pkgName !== "changed packages" && pkgName !== "unchanged packages"
+    );
+  }
+  return [allPackages[0].packageJson.name];
+}
+
+function getPkgJsonsByName(packages: Package[]) {
+  return new Map(
+    packages.map(({ packageJson }) => [packageJson.name, packageJson])
+  );
+}
+
+function isValidChangesetPackage(
+  packageJson: PackageJSON,
+  ignorePrivatePackages: boolean
+) {
+  const hasVersionField = !!packageJson.version;
+
+  if (ignorePrivatePackages && packageJson.private) {
+    return false;
+  }
+
+  return hasVersionField;
+}
+
+function formatPkgNameAndVersion(pkgName: string, version: string) {
+  return `${bold(pkgName)}@${bold(version)}`;
+}
+
+export default async function createChangeset(
+  changedPackages: Array<string>,
+  allPackages: Package[],
+  ignorePrivatePackages: boolean
+): Promise<{ confirmed: boolean; summary: string; releases: Array<Release> }> {
+  const releases: Array<Release> = [];
+
+  if (allPackages.length > 1) {
+    const packagesToRelease = await getPackagesToRelease(
+      changedPackages,
+      allPackages,
+      ignorePrivatePackages
+    );
+
+    let pkgJsonsByName = getPkgJsonsByName(allPackages);
+
+    let pkgsLeftToGetBumpTypeFor = new Set(packagesToRelease);
+
+    let pkgsThatShouldBeMajorBumped = (
+      await cli.askCheckboxPlus(
+        bold(`Which packages should have a ${red("major")} bump?`),
+        [
+          {
+            name: "all packages",
+            choices: packagesToRelease.map(pkgName => {
+              return {
+                name: pkgName,
+                message: formatPkgNameAndVersion(
+                  pkgName,
+                  pkgJsonsByName.get(pkgName)!.version
+                )
+              };
+            })
+          }
+        ],
+        x => {
+          // this removes changed packages and unchanged packages from the list
+          // of packages shown after selection
+          if (Array.isArray(x)) {
+            return x
+              .filter(x => x !== "all packages")
+              .map(x => cyan(x))
+              .join(", ");
+          }
+          return x;
+        }
+      )
+    ).filter(x => x !== "all packages");
+
+    for (const pkgName of pkgsThatShouldBeMajorBumped) {
+      // for packages that are under v1, we want to make sure major releases are intended,
+      // as some repo-wide sweeping changes have mistakenly release first majors
+      // of packages.
+      let pkgJson = pkgJsonsByName.get(pkgName)!;
+
+      let shouldReleaseFirstMajor = await confirmMajorRelease(pkgJson);
+      if (shouldReleaseFirstMajor) {
+        pkgsLeftToGetBumpTypeFor.delete(pkgName);
+
+        releases.push({ name: pkgName, type: "major" });
+      }
+    }
+
+    if (pkgsLeftToGetBumpTypeFor.size !== 0) {
+      let pkgsThatShouldBeMinorBumped = (
+        await cli.askCheckboxPlus(
+          bold(`Which packages should have a ${green("minor")} bump?`),
+          [
+            {
+              name: "all packages",
+              choices: [...pkgsLeftToGetBumpTypeFor].map(pkgName => {
+                return {
+                  name: pkgName,
+                  message: formatPkgNameAndVersion(
+                    pkgName,
+                    pkgJsonsByName.get(pkgName)!.version
+                  )
+                };
+              })
+            }
+          ],
+          x => {
+            // this removes changed packages and unchanged packages from the list
+            // of packages shown after selection
+            if (Array.isArray(x)) {
+              return x
+                .filter(x => x !== "all packages")
+                .map(x => cyan(x))
+                .join(", ");
+            }
+            return x;
+          }
+        )
+      ).filter(x => x !== "all packages");
+
+      for (const pkgName of pkgsThatShouldBeMinorBumped) {
+        pkgsLeftToGetBumpTypeFor.delete(pkgName);
+
+        releases.push({ name: pkgName, type: "minor" });
+      }
+    }
+
+    if (pkgsLeftToGetBumpTypeFor.size !== 0) {
+      log(`The following packages will be ${blue("patch")} bumped:`);
+      pkgsLeftToGetBumpTypeFor.forEach(pkgName => {
+        log(
+          formatPkgNameAndVersion(pkgName, pkgJsonsByName.get(pkgName)!.version)
+        );
+      });
+
+      for (const pkgName of pkgsLeftToGetBumpTypeFor) {
+        releases.push({ name: pkgName, type: "patch" });
+      }
+    }
+  } else {
+    let pkg = allPackages[0];
+    let type = await cli.askList(
+      `What kind of change is this for ${green(
+        pkg.packageJson.name
+      )}? (current version is ${pkg.packageJson.version})`,
+      ["patch", "minor", "major"]
+    );
+    if (type === "major") {
+      let shouldReleaseAsMajor = await confirmMajorRelease(pkg.packageJson);
+      if (!shouldReleaseAsMajor) {
+        throw new ExitError(1);
+      }
+    }
+    releases.push({ name: pkg.packageJson.name, type });
+  }
+
+  log(
+    "Please enter a summary for this change (this will be in the changelogs)."
+  );
+  log(chalk.gray("  (submit empty line to open external editor)"));
+
+  let summary = await cli.askQuestion("Summary");
+  if (summary.length === 0) {
+    try {
+      summary = cli.askQuestionWithEditor(
+        "\n\n# Please enter a summary for your changes.\n# An empty message aborts the editor."
+      );
+      if (summary.length > 0) {
+        return {
+          confirmed: true,
+          summary,
+          releases
+        };
+      }
+    } catch (err) {
+      log(
+        "An error happened using external editor. Please type your summary here:"
+      );
+    }
+
+    summary = await cli.askQuestion("");
+    while (summary.length === 0) {
+      summary = await cli.askQuestion(
+        "\n\n# A summary is required for the changelog! 😪"
+      );
+    }
+  }
+
+  return {
+    confirmed: false,
+    summary,
+    releases
+  };
+}
diff --git a/node_modules/@changesets/cli/src/commands/add/index.ts b/node_modules/@changesets/cli/src/commands/add/index.ts
new file mode 100644
index 0000000..e188f42
--- /dev/null
+++ b/node_modules/@changesets/cli/src/commands/add/index.ts
@@ -0,0 +1,112 @@
+import chalk from "chalk";
+import path from "path";
+import { spawn } from "child_process";
+
+import * as cli from "../../utils/cli-utilities";
+import * as git from "@changesets/git";
+import { info, log, warn } from "@changesets/logger";
+import { Config, PrivatePackages } from "@changesets/types";
+import { getPackages } from "@manypkg/get-packages";
+import writeChangeset from "@changesets/write";
+
+import { getCommitFunctions } from "../../commit/getCommitFunctions";
+import createChangeset from "./createChangeset";
+import printConfirmationMessage from "./messages";
+import { ExternalEditor } from "external-editor";
+
+type UnwrapPromise<T extends Promise<any>> = T extends Promise<infer R>
+  ? R
+  : never;
+
+export default async function add(
+  cwd: string,
+  { empty, open }: { empty?: boolean; open?: boolean },
+  config: Config
+) {
+  const packages = await getPackages(cwd);
+  const changesetBase = path.resolve(cwd, ".changeset");
+
+  let newChangeset: UnwrapPromise<ReturnType<typeof createChangeset>>;
+  if (empty) {
+    newChangeset = {
+      confirmed: true,
+      releases: [],
+      summary: ``
+    };
+  } else {
+    const changedPackages = await git.getChangedPackagesSinceRef({
+      cwd,
+      ref: config.baseBranch
+    });
+    const changePackagesName = changedPackages
+      .filter(a => a)
+      .map(pkg => pkg.packageJson.name);
+    newChangeset = await createChangeset(
+      changePackagesName,
+      packages.packages,
+      config.privatePackages === PrivatePackages.Ignore
+    );
+    printConfirmationMessage(newChangeset, packages.packages.length > 1);
+
+    if (!newChangeset.confirmed) {
+      newChangeset = {
+        ...newChangeset,
+        confirmed: await cli.askConfirm("Is this your desired changeset?")
+      };
+    }
+  }
+
+  if (newChangeset.confirmed) {
+    const changesetID = await writeChangeset(newChangeset, cwd);
+    const [{ getAddMessage }, commitOpts] = getCommitFunctions(
+      config.commit,
+      cwd
+    );
+    if (getAddMessage) {
+      await git.add(path.resolve(changesetBase, `${changesetID}.md`), cwd);
+      await git.commit(await getAddMessage(newChangeset, commitOpts), cwd);
+      log(chalk.green(`${empty ? "Empty " : ""}Changeset added and committed`));
+    } else {
+      log(
+        chalk.green(
+          `${empty ? "Empty " : ""}Changeset added! - you can now commit it\n`
+        )
+      );
+    }
+
+    let hasMajorChange = [...newChangeset.releases].find(
+      c => c.type === "major"
+    );
+
+    if (hasMajorChange) {
+      warn(
+        "This Changeset includes a major change and we STRONGLY recommend adding more information to the changeset:"
+      );
+      warn("WHAT the breaking change is");
+      warn("WHY the change was made");
+      warn("HOW a consumer should update their code");
+    } else {
+      log(
+        chalk.green(
+          "If you want to modify or expand on the changeset summary, you can find it here"
+        )
+      );
+    }
+    const changesetPath = path.resolve(changesetBase, `${changesetID}.md`);
+    info(chalk.blue(changesetPath));
+
+    if (open) {
+      // this is really a hack to reuse the logic embedded in `external-editor` related to determining the editor
+      const externalEditor = new ExternalEditor();
+      externalEditor.cleanup();
+      spawn(
+        externalEditor.editor.bin,
+        externalEditor.editor.args.concat([changesetPath]),
+        {
+          detached: true,
+          stdio: "inherit"
+        }
+      );
+    }
+  }
+}
diff --git a/node_modules/@changesets/cli/src/commands/add/messages.ts b/node_modules/@changesets/cli/src/commands/add/messages.ts
new file mode 100644
index 0000000..2bb83af
--- /dev/null
+++ b/node_modules/@changesets/cli/src/commands/add/messages.ts
@@ -0,0 +1,42 @@
+import chalk from "chalk";
+import outdent from "outdent";
+import { log } from "@changesets/logger";
+import { Release, VersionType } from "@changesets/types";
+
+export default function printConfirmationMessage(
+  changeset: {
+    releases: Array<Release>;
+    summary: string;
+  },
+  repoHasMultiplePackages: boolean
+) {
+  function getReleasesOfType(type: VersionType) {
+    return changeset.releases
+      .filter(release => release.type === type)
+      .map(release => release.name);
+  }
+  log("\n=== Summary of changesets ===");
+  const majorReleases = getReleasesOfType("major");
+  const minorReleases = getReleasesOfType("minor");
+  const patchReleases = getReleasesOfType("patch");
+
+  if (majorReleases.length > 0)
+    log(`${chalk.bold.green("major")}:  ${majorReleases.join(", ")}`);
+  if (minorReleases.length > 0)
+    log(`${chalk.bold.green("minor")}:  ${minorReleases.join(", ")}`);
+  if (patchReleases.length > 0)
+    log(`${chalk.bold.green("patch")}:  ${patchReleases.join(", ")}`);
+
+  log("");
+
+  if (repoHasMultiplePackages) {
+    const message = outdent`
+      Note: All dependents of these packages that will be incompatible with
+      the new version will be ${chalk.redBright(
+        "patch bumped"
+      )} when this changeset is applied.
+    `;
+
+    log(message + "\n");
+  }
+}
diff --git a/node_modules/@changesets/cli/src/commands/init/__tests__/command.ts b/node_modules/@changesets/cli/src/commands/init/__tests__/command.ts
new file mode 100644
index 0000000..11e6ecd
--- /dev/null
+++ b/node_modules/@changesets/cli/src/commands/init/__tests__/command.ts
@@ -0,0 +1,56 @@
+import fixtures from "fixturez";
+import fs from "fs-extra";
+import path from "path";
+import { defaultWrittenConfig } from "@changesets/config";
+import { silenceLogsInBlock } from "@changesets/test-utils";
+
+import initializeCommand from "..";
+
+const f = fixtures(__dirname);
+
+const getPaths = (cwd: string) => ({
+  readmePath: path.join(cwd, ".changeset/README.md"),
+  configPath: path.join(cwd, ".changeset/config.json")
+});
+
+describe("init", () => {
+  silenceLogsInBlock();
+  it("should initialize in a project without a .changeset folder", async () => {
+    const cwd = await f.copy("without-existing-changeset");
+    const { readmePath, configPath } = getPaths(cwd);
+
+    expect(fs.pathExistsSync(readmePath)).toBe(false);
+    expect(fs.pathExistsSync(configPath)).toBe(false);
+    await initializeCommand(cwd);
+    expect(fs.pathExistsSync(readmePath)).toBe(true);
+    expect(fs.pathExistsSync(configPath)).toBe(true);
+  });
+  it("should write the default config if it doesn't exist", async () => {
+    const cwd = await f.copy("simple-project");
+    await fs.remove(path.join(cwd, ".changeset/config.json"));
+
+    expect(fs.pathExistsSync(path.join(cwd, ".changeset/README.md"))).toBe(
+      true
+    );
+    await initializeCommand(cwd);
+    expect(
+      await fs.readJson(path.join(cwd, ".changeset/config.json"))
+    ).toEqual({ ...defaultWrittenConfig, baseBranch: "main" });
+  });
+  it("shouldn't overwrite a config if it does exist", async () => {
+    const cwd = await f.copy("simple-project");
+    await fs.writeJson(path.join(cwd, ".changeset/config.json"), {
+      changelog: false
+    });
+
+    expect(fs.pathExistsSync(path.join(cwd, ".changeset/README.md"))).toBe(
+      true
+    );
+    await initializeCommand(cwd);
+    expect(await fs.readJson(path.join(cwd, ".changeset/config.json"))).toEqual(
+      {
+        changelog: false
+      }
+    );
+  });
+});
diff --git a/node_modules/@changesets/cli/src/commands/init/index.ts b/node_modules/@changesets/cli/src/commands/init/index.ts
new file mode 100644
index 0000000..5e5757f
--- /dev/null
+++ b/node_modules/@changesets/cli/src/commands/init/index.ts
@@ -0,0 +1,71 @@
+import path from "path";
+import fs from "fs-extra";
+import chalk from "chalk";
+
+import { defaultWrittenConfig } from "@changesets/config";
+import { info, log, warn, error } from "@changesets/logger";
+
+const pkgPath = path.dirname(require.resolve("@changesets/cli/package.json"));
+
+// Modify base branch to "main" without changing defaultWrittenConfig since it also serves as a fallback
+// for config files that don't specify a base branch. Changing that to main would be a breaking change.
+const defaultConfig = JSON.stringify(
+  { ...defaultWrittenConfig, baseBranch: "main" },
+  null,
+  2
+);
+
+export default async function init(cwd: string) {
+  const changesetBase = path.resolve(cwd, ".changeset");
+
+  if (fs.existsSync(changesetBase)) {
+    if (!fs.existsSync(path.join(changesetBase, "config.json"))) {
+      if (fs.existsSync(path.join(changesetBase, "config.js"))) {
+        error(
+          "It looks like you're using the version 1 `.changeset/config.js` file"
+        );
+        error(
+          "The format of the config object has significantly changed in v2 as well"
+        );
+        error(
+          " - we thoroughly recommend looking at the changelog for this package for what has changed"
+        );
+        error(
+          "Changesets will write the defaults for the new config, remember to transfer your options into the new config at `.changeset/config.json`"
+        );
+      } else {
+        error("It looks like you don't have a config file");
+        info(
+          "The default config file will be written at `.changeset/config.json`"
+        );
+      }
+      await fs.writeFile(
+        path.resolve(changesetBase, "config.json"),
+        defaultConfig
+      );
+    } else {
+      warn(
+        "It looks like you already have changesets initialized. You should be able to run changeset commands no problems."
+      );
+    }
+  } else {
+    await fs.copy(path.resolve(pkgPath, "./default-files"), changesetBase);
+    await fs.writeFile(
+      path.resolve(changesetBase, "config.json"),
+      defaultConfig
+    );
+
+    log(
+      chalk`Thanks for choosing {green changesets} to help manage your versioning and publishing\n`
+    );
+    log("You should be set up to start using changesets now!\n");
+
+    info(
+      "We have added a `.changeset` folder, and a couple of files to help you out:"
+    );
+    info(
+      chalk`- {blue .changeset/README.md} contains information about using changesets`
+    );
+    info(chalk`- {blue .changeset/config.json} is our default config`);
+  }
+}
diff --git a/node_modules/@changesets/cli/src/commands/pre/index.test.ts b/node_modules/@changesets/cli/src/commands/pre/index.test.ts
new file mode 100644
index 0000000..3f0c430
--- /dev/null
+++ b/node_modules/@changesets/cli/src/commands/pre/index.test.ts
@@ -0,0 +1,110 @@
+import fixturez from "fixturez";
+import path from "path";
+import chalk from "chalk";
+import * as fs from "fs-extra";
+import { PreState } from "@changesets/types";
+import * as logger from "@changesets/logger";
+import { ExitError } from "@changesets/errors";
+
+import pre from "./index";
+
+let f = fixturez(__dirname);
+
+let preStateForSimpleProject: PreState = {
+  changesets: [],
+  initialVersions: {
+    "pkg-a": "1.0.0",
+    "pkg-b": "1.0.0"
+  },
+  mode: "pre",
+  tag: "next"
+};
+
+let preStateForExited: PreState = {
+  changesets: ["slimy-dingos-whisper"],
+  initialVersions: {
+    "pkg-a": "1.0.0",
+    "pkg-b": "1.0.0"
+  },
+  mode: "exit",
+  tag: "beta"
+};
+
+jest.mock("@changesets/logger");
+
+let mockedLogger = logger as jest.Mocked<typeof logger>;
+
+describe("enterPre", () => {
+  it("should enter", async () => {
+    let cwd = f.copy("simple-project");
+    await pre(cwd, { command: "enter", tag: "next" });
+
+    expect(await fs.readJson(path.join(cwd, ".changeset", "pre.json"))).toEqual(
+      preStateForSimpleProject
+    );
+    expect(mockedLogger.success).toBeCalledWith(
+      `Entered pre mode with tag ${chalk.cyan("next")}`
+    );
+  });
+  it("should throw if already in pre", async () => {
+    let cwd = f.copy("simple-project");
+    await fs.writeJSON(
+      path.join(cwd, ".changeset", "pre.json"),
+      preStateForSimpleProject
+    );
+    await expect(
+      pre(cwd, { command: "enter", tag: "next" })
+    ).rejects.toBeInstanceOf(ExitError);
+    expect(mockedLogger.error).toBeCalledWith(
+      "`changeset pre enter` cannot be run when in pre mode"
+    );
+    expect(logger.info).toBeCalledWith(
+      "If you're trying to exit pre mode, run `changeset pre exit`"
+    );
+  });
+  it("should enter if already exited pre mode", async () => {
+    let cwd = f.copy("simple-project");
+    await fs.writeJSON(
+      path.join(cwd, ".changeset", "pre.json"),
+      preStateForExited
+    );
+    await pre(cwd, { command: "enter", tag: "next" });
+    expect(await fs.readJson(path.join(cwd, ".changeset", "pre.json"))).toEqual(
+      {
+        ...preStateForExited,
+        mode: "pre",
+        tag: "next"
+      }
+    );
+    expect(mockedLogger.success).toBeCalledWith(
+      `Entered pre mode with tag ${chalk.cyan("next")}`
+    );
+  });
+});
+
+describe("exitPre", () => {
+  it("should exit", async () => {
+    let cwd = f.copy("simple-project");
+    await fs.writeJSON(
+      path.join(cwd, ".changeset", "pre.json"),
+      preStateForSimpleProject
+    );
+    await pre(cwd, { command: "exit" });
+
+    expect(
+      await fs.readJson(path.join(cwd, ".changeset", "pre.json"))
+    ).toEqual({ ...preStateForSimpleProject, mode: "exit" });
+  });
+  it("should throw if not in pre", async () => {
+    let cwd = f.copy("simple-project");
+    await expect(pre(cwd, { command: "exit" })).rejects.toBeInstanceOf(
+      ExitError
+    );
+    expect(mockedLogger.error).toBeCalledWith(
+      "`changeset pre exit` can only be run when in pre mode"
+    );
+    expect(logger.info).toBeCalledWith(
+      "If you're trying to enter pre mode, run `changeset pre enter`"
+    );
+  });
+});
diff --git a/node_modules/@changesets/cli/src/commands/pre/index.ts b/node_modules/@changesets/cli/src/commands/pre/index.ts
new file mode 100644
index 0000000..52779c2
--- /dev/null
+++ b/node_modules/@changesets/cli/src/commands/pre/index.ts
@@ -0,0 +1,49 @@
+import * as logger from "@changesets/logger";
+import chalk from "chalk";
+import { exitPre, enterPre } from "@changesets/pre";
+import {
+  PreExitButNotInPreModeError,
+  PreEnterButInPreModeError,
+  ExitError
+} from "@changesets/errors";
+
+export default async function pre(
+  cwd: string,
+  options: { command: "enter"; tag: string } | { command: "exit"; tag?: string }
+) {
+  if (options.command === "enter") {
+    try {
+      await enterPre(cwd, options.tag);
+      logger.success(`Entered pre mode with tag ${chalk.cyan(options.tag)}`);
+      logger.info(
+        "Run `changeset version` to version packages with prerelease versions"
+      );
+    } catch (err) {
+      if (err instanceof PreEnterButInPreModeError) {
+        logger.error("`changeset pre enter` cannot be run when in pre mode");
+        logger.info(
+          "If you're trying to exit pre mode, run `changeset pre exit`"
+        );
+        throw new ExitError(1);
+      }
+      throw err;
+    }
+  } else {
+    try {
+      await exitPre(cwd);
+      logger.success(`Exited pre mode`);
+      logger.info(
+        "Run `changeset version` to version packages with normal versions"
+      );
+    } catch (err) {
+      if (err instanceof PreExitButNotInPreModeError) {
+        logger.error("`changeset pre exit` can only be run when in pre mode");
+        logger.info(
+          "If you're trying to enter pre mode, run `changeset pre enter`"
+        );
+        throw new ExitError(1);
+      }
+      throw err;
+    }
+  }
+}
diff --git a/node_modules/@changesets/cli/src/commands/publish/__tests__/index.test.ts b/node_modules/@changesets/cli/src/commands/publish/__tests__/index.test.ts
new file mode 100644
index 0000000..e4069a4
--- /dev/null
+++ b/node_modules/@changesets/cli/src/commands/publish/__tests__/index.test.ts
@@ -0,0 +1,39 @@
+import fixtures from "fixturez";
+import publishCommand from "../index";
+import { defaultConfig } from "@changesets/config";
+import * as path from "path";
+import * as pre from "@changesets/pre";
+import { Config } from "@changesets/types";
+import { silenceLogsInBlock } from "@changesets/test-utils";
+
+let changelogPath = path.resolve(__dirname, "../../changelog");
+let modifiedDefaultConfig: Config = {
+  ...defaultConfig,
+  changelog: [changelogPath, null]
+};
+
+const f = fixtures(__dirname);
+
+jest.mock("../npm-utils.ts");
+jest.mock("../publishPackages.ts");
+jest.mock("@changesets/pre");
+
+describe("Publish command", () => {
+  silenceLogsInBlock();
+  let cwd: string;
+
+  beforeEach(async () => {
+    cwd = await f.copy("simple-project");
+  });
+  describe("in pre state", () => {
+    beforeEach(() => {
+      // @ts-ignore
+      pre.readPreState.mockImplementation(() => ({ mode: "pre" }));
+    });
+    it("should report error if the tag option is used in pre release", async () => {
+      await expect(
+        publishCommand(cwd, { tag: "experimental" }, modifiedDefaultConfig)
+      ).rejects.toThrowError();
+    });
+  });
+});
diff --git a/node_modules/@changesets/cli/src/commands/publish/__tests__/publishPackages.test.ts b/node_modules/@changesets/cli/src/commands/publish/__tests__/publishPackages.test.ts
new file mode 100644
index 0000000..b9e0d3e
--- /dev/null
+++ b/node_modules/@changesets/cli/src/commands/publish/__tests__/publishPackages.test.ts
@@ -0,0 +1,49 @@
+import fixtures from "fixturez";
+
+import publishPackages from "../publishPackages";
+import * as npmUtils from "../npm-utils";
+import { getPackages } from "@manypkg/get-packages";
+import { silenceLogsInBlock } from "@changesets/test-utils";
+
+jest.mock("../npm-utils");
+jest.mock("is-ci", () => true);
+
+const f = fixtures(__dirname);
+
+describe("publishPackages", () => {
+  silenceLogsInBlock();
+  let cwd: string;
+
+  beforeEach(async () => {
+    cwd = await f.copy("simple-project");
+
+    // @ts-ignore
+    npmUtils.infoAllow404.mockImplementation(() => ({
+      published: false,
+      pkgInfo: {
+        version: "1.0.0"
+      }
+    }));
+
+    // @ts-ignore
+    npmUtils.publish.mockImplementation(() => ({
+      published: true
+    }));
+  });
+
+  afterEach(() => {
+    jest.clearAllMocks();
+  });
+
+  describe("when isCI", () => {
+    it("does not call out to npm to see if otp is required", async () => {
+      await publishPackages({
+        packages: (await getPackages(cwd)).packages,
+        access: "public",
+        preState: undefined,
+        tagPrivatePackages: true
+      });
+      expect(npmUtils.getTokenIsRequired).not.toHaveBeenCalled();
+    });
+  });
+});
diff --git a/node_modules/@changesets/cli/src/commands/publish/__tests__/releaseCommand.test.ts b/node_modules/@changesets/cli/src/commands/publish/__tests__/releaseCommand.test.ts
new file mode 100644
index 0000000..2abc59f
--- /dev/null
+++ b/node_modules/@changesets/cli/src/commands/publish/__tests__/releaseCommand.test.ts
@@ -0,0 +1,54 @@
+import fixtures from "fixturez";
+
+import publishPackages from "../publishPackages";
+import * as git from "@changesets/git";
+import { defaultConfig } from "@changesets/config";
+import { silenceLogsInBlock } from "@changesets/test-utils";
+import runRelease from "..";
+
+jest.mock("../../../utils/cli-utilities");
+jest.mock("@changesets/git");
+jest.mock("../publishPackages");
+
+const f = fixtures(__dirname);
+
+// @ts-ignore
+git.tag.mockImplementation(() => Promise.resolve(true));
+// we want to keep other bolt commands still running so our tests are more e2e
+// NOTE: This is pretty terrible. Quite obviously bolt is not going to return these results
+// each time, but there is only one test that uses the output of this function ('should add git tags')
+// and we know this will be heavily refactored once its moved into the bolt org anyway. So we are happy
+// to keep this debt in for now. LB takes full responsibility for this if it becomes flakey.
+
+// @ts-ignore
+publishPackages.mockImplementation(() =>
+  Promise.resolve({
+    publishedPackages: [
+      { name: "pkg-a", newVersion: "1.1.0", published: true },
+      { name: "pkg-b", newVersion: "1.0.1", published: true }
+    ],
+    untaggedPrivatePackages: [
+      { name: "project-a", newVersion: "2.0.5", published: true }
+    ]
+  })
+);
+
+describe("running release", () => {
+  silenceLogsInBlock();
+  let cwd: string;
+
+  beforeEach(async () => {
+    cwd = await f.copy("simple-project");
+  });
+
+  describe("When there is no changeset commits", () => {
+    // we make sure we still do this so that a later build can clean up after a previously
+    // failed one (where the change was pushed back but not released and the next build has no
+    // changeset commits)
+    it("should still run publishPackages", async () => {
+      await runRelease(cwd, {}, defaultConfig);
+
+      expect(publishPackages).toHaveBeenCalled();
+    });
+  });
+});
diff --git a/node_modules/@changesets/cli/src/commands/publish/index.ts b/node_modules/@changesets/cli/src/commands/publish/index.ts
new file mode 100644
index 0000000..3939f15
--- /dev/null
+++ b/node_modules/@changesets/cli/src/commands/publish/index.ts
@@ -0,0 +1,131 @@
+import publishPackages from "./publishPackages";
+import { ExitError } from "@changesets/errors";
+import { error, log, success, warn } from "@changesets/logger";
+import * as git from "@changesets/git";
+import { readPreState } from "@changesets/pre";
+import { Config, PreState, PrivatePackages } from "@changesets/types";
+import { getPackages } from "@manypkg/get-packages";
+import chalk from "chalk";
+
+function logReleases(pkgs: Array<{ name: string; newVersion: string }>) {
+  const mappedPkgs = pkgs.map(p => `${p.name}@${p.newVersion}`).join("\n");
+  log(mappedPkgs);
+}
+
+let importantSeparator = chalk.red(
+  "===============================IMPORTANT!==============================="
+);
+
+let importantEnd = chalk.red(
+  "----------------------------------------------------------------------"
+);
+
+function showNonLatestTagWarning(tag?: string, preState?: PreState) {
+  warn(importantSeparator);
+  if (preState) {
+    warn(
+      `You are in prerelease mode so packages will be published to the ${chalk.cyan(
+        preState.tag
+      )}
+        dist tag except for packages that have not had normal releases which will be published to ${chalk.cyan(
+          "latest"
+        )}`
+    );
+  } else if (tag !== "latest") {
+    warn(`Packages will be released under the ${tag} tag`);
+  }
+  warn(importantEnd);
+}
+
+export default async function run(
+  cwd: string,
+  { otp, tag, gitTag = true }: { otp?: string; tag?: string; gitTag?: boolean },
+  config: Config
+) {
+  const releaseTag = tag && tag.length > 0 ? tag : undefined;
+  let preState = await readPreState(cwd);
+
+  if (releaseTag && preState && preState.mode === "pre") {
+    error("Releasing under custom tag is not allowed in pre mode");
+    log("To resolve this exit the pre mode by running `changeset pre exit`");
+    throw new ExitError(1);
+  }
+
+  if (releaseTag || preState) {
+    showNonLatestTagWarning(tag, preState);
+  }
+
+  const { packages, tool } = await getPackages(cwd);
+
+  const response = await publishPackages({
+    packages,
+    // if not public, we won't pass the access, and it works as normal
+    access: config.access,
+    otp,
+    preState,
+    tag: releaseTag,
+    tagPrivatePackages: isFlagEnabled(
+      config.privatePackages,
+      PrivatePackages.Tag
+    )
+  });
+
+  const successfulNpmPublishes = response.publishedPackages.filter(
+    p => p.published
+  );
+  const unsuccessfulNpmPublishes = response.publishedPackages.filter(
+    p => !p.published
+  );
+  const untaggedPrivatePackages = response.untaggedPrivatePackages;
+
+  if (successfulNpmPublishes.length > 0) {
+    success("packages published successfully:");
+    logReleases(successfulNpmPublishes);
+
+    if (gitTag) {
+      // We create the tags after the push above so that we know that HEAD won't change and that pushing
+      // won't suffer from a race condition if another merge happens in the mean time (pushing tags won't
+      // fail if we are behind the base branch).
+      log(`Creating git tag${successfulNpmPublishes.length > 1 ? "s" : ""}...`);
+      if (tool !== "root") {
+        for (const pkg of successfulNpmPublishes) {
+          const tag = `${pkg.name}@${pkg.newVersion}`;
+          log("New tag: ", tag);
+          await git.tag(tag, cwd);
+        }
+      } else {
+        const tag = `v${successfulNpmPublishes[0].newVersion}`;
+        log("New tag: ", tag);
+        await git.tag(tag, cwd);
+      }
+    }
+  }
+
+  if (untaggedPrivatePackages.length > 0) {
+    success("found untagged projects:");
+    logReleases(untaggedPrivatePackages);
+
+    if (tool !== "root") {
+      for (const pkg of untaggedPrivatePackages) {
+        const tag = `${pkg.name}@${pkg.newVersion}`;
+        log("New tag: ", tag);
+        await git.tag(tag, cwd);
+      }
+    } else {
+      const tag = `v${untaggedPrivatePackages[0].newVersion}`;
+      log("New tag: ", tag);
+      await git.tag(tag, cwd);
+    }
+  }
+
+  if (unsuccessfulNpmPublishes.length > 0) {
+    error("packages failed to publish:");
+
+    logReleases(unsuccessfulNpmPublishes);
+    throw new ExitError(1);
+  }
+}
+
+function isFlagEnabled(value: number, tag: number): boolean {
+  return (value & tag) === tag;
+}
diff --git a/node_modules/@changesets/cli/src/commands/publish/npm-utils.ts b/node_modules/@changesets/cli/src/commands/publish/npm-utils.ts
new file mode 100644
index 0000000..df10e8d
--- /dev/null
+++ b/node_modules/@changesets/cli/src/commands/publish/npm-utils.ts
@@ -0,0 +1,233 @@
+import { ExitError } from "@changesets/errors";
+import { error, info, warn } from "@changesets/logger";
+import { PackageJSON } from "@changesets/types";
+import pLimit from "p-limit";
+import preferredPM from "preferred-pm";
+import chalk from "chalk";
+import spawn from "spawndamnit";
+import semver from "semver";
+import { askQuestion } from "../../utils/cli-utilities";
+import isCI from "is-ci";
+import { TwoFactorState } from "../../utils/types";
+import { getLastJsonObjectFromString } from "../../utils/getLastJsonObjectFromString";
+
+const npmRequestLimit = pLimit(40);
+const npmPublishLimit = pLimit(10);
+
+function jsonParse(input: string) {
+  try {
+    return JSON.parse(input);
+  } catch (err) {
+    if (err instanceof SyntaxError) {
+      console.error("error parsing json:", input);
+    }
+    throw err;
+  }
+}
+
+function getCorrectRegistry(packageJson?: PackageJSON): string {
+  const registry =
+    packageJson?.publishConfig?.registry ?? process.env.npm_config_registry;
+
+  return !registry || registry === "https://registry.yarnpkg.com"
+    ? "https://registry.npmjs.org"
+    : registry;
+}
+
+async function getPublishTool(
+  cwd: string
+): Promise<{ name: "npm" } | { name: "pnpm"; shouldAddNoGitChecks: boolean }> {
+  const pm = await preferredPM(cwd);
+  if (!pm || pm.name !== "pnpm") return { name: "npm" };
+  try {
+    let result = await spawn("pnpm", ["--version"], { cwd });
+    let version = result.stdout.toString().trim();
+    let parsed = semver.parse(version);
+    return {
+      name: "pnpm",
+      shouldAddNoGitChecks:
+        parsed?.major === undefined ? false : parsed.major >= 5
+    };
+  } catch (e) {
+    return {
+      name: "pnpm",
+      shouldAddNoGitChecks: false
+    };
+  }
+}
+
+export async function getTokenIsRequired() {
+  // Due to a super annoying issue in yarn, we have to manually override this env variable
+  // See: https://github.com/yarnpkg/yarn/issues/2935#issuecomment-355292633
+  const envOverride = {
+    npm_config_registry: getCorrectRegistry()
+  };
+  let result = await spawn("npm", ["profile", "get", "--json"], {
+    env: Object.assign({}, process.env, envOverride)
+  });
+  if (result.code !== 0) {
+    error(
+      "error while checking if token is required",
+      result.stderr.toString().trim() || result.stdout.toString().trim()
+    );
+    return false;
+  }
+  let json = jsonParse(result.stdout.toString());
+  if (json.error || !json.tfa || !json.tfa.mode) {
+    return false;
+  }
+  return json.tfa.mode === "auth-and-writes";
+}
+
+export function getPackageInfo(packageJson: PackageJSON) {
+  return npmRequestLimit(async () => {
+    info(`npm info ${packageJson.name}`);
+
+    // Due to a couple of issues with yarnpkg, we also want to override the npm registry when doing
+    // npm info.
+    // Issues: We sometimes get back cached responses, i.e old data about packages which causes
+    // `publish` to behave incorrectly. It can also cause issues when publishing private packages
+    // as they will always give a 404, which will tell `publish` to always try to publish.
+    // See: https://github.com/yarnpkg/yarn/issues/2935#issuecomment-355292633
+    let result = await spawn("npm", [
+      "info",
+      packageJson.name,
+      "--registry",
+      getCorrectRegistry(packageJson),
+      "--json"
+    ]);
+
+    // Github package registry returns empty string when calling npm info
+    // for a non-existent package instead of a E404
+    if (result.stdout.toString() === "") {
+      return {
+        error: {
+          code: "E404"
+        }
+      };
+    }
+    return jsonParse(result.stdout.toString());
+  });
+}
+
+export async function infoAllow404(packageJson: PackageJSON) {
+  let pkgInfo = await getPackageInfo(packageJson);
+  if (pkgInfo.error?.code === "E404") {
+    warn(`Received 404 for npm info ${chalk.cyan(`"${packageJson.name}"`)}`);
+    return { published: false, pkgInfo: {} };
+  }
+  if (pkgInfo.error) {
+    error(
+      `Received an unknown error code: ${
+        pkgInfo.error.code
+      } for npm info ${chalk.cyan(`"${packageJson.name}"`)}`
+    );
+    error(pkgInfo.error.summary);
+    if (pkgInfo.error.detail) error(pkgInfo.error.detail);
+
+    throw new ExitError(1);
+  }
+  return { published: true, pkgInfo };
+}
+
+let otpAskLimit = pLimit(1);
+
+let askForOtpCode = (twoFactorState: TwoFactorState) =>
+  otpAskLimit(async () => {
+    if (twoFactorState.token !== null) return twoFactorState.token;
+    info(
+      "This operation requires a one-time password from your authenticator."
+    );
+
+    let val = await askQuestion("Enter one-time password:");
+    twoFactorState.token = val;
+    return val;
+  });
+
+export let getOtpCode = async (twoFactorState: TwoFactorState) => {
+  if (twoFactorState.token !== null) {
+    return twoFactorState.token;
+  }
+  return askForOtpCode(twoFactorState);
+};
+
+// we have this so that we can do try a publish again after a publish without
+// the call being wrapped in the npm request limit and causing the publishes to potentially never run
+async function internalPublish(
+  pkgName: string,
+  opts: { cwd: string; access?: string; tag: string },
+  twoFactorState: TwoFactorState
+): Promise<{ published: boolean }> {
+  let publishTool = await getPublishTool(opts.cwd);
+  let publishFlags = opts.access ? ["--access", opts.access] : [];
+  publishFlags.push("--tag", opts.tag);
+  if ((await twoFactorState.isRequired) && !isCI) {
+    let otpCode = await getOtpCode(twoFactorState);
+    publishFlags.push("--otp", otpCode);
+  }
+  if (publishTool.name === "pnpm" && publishTool.shouldAddNoGitChecks) {
+    publishFlags.push("--no-git-checks");
+  }
+
+  // Due to a super annoying issue in yarn, we have to manually override this env variable
+  // See: https://github.com/yarnpkg/yarn/issues/2935#issuecomment-355292633
+  const envOverride = {
+    npm_config_registry: getCorrectRegistry()
+  };
+  let { code, stdout, stderr } = await spawn(
+    publishTool.name,
+    ["publish", opts.cwd, "--json", ...publishFlags],
+    {
+      env: Object.assign({}, process.env, envOverride)
+    }
+  );
+  if (code !== 0) {
+    // NPM's --json output is included alongside the `prepublish` and `postpublish` output in terminal
+    // We want to handle this as best we can but it has some struggles:
+    // - output of those lifecycle scripts can contain JSON
+    // - npm7 has switched to printing `--json` errors to stderr (https://github.com/npm/cli/commit/1dbf0f9bb26ba70f4c6d0a807701d7652c31d7d4)
+    // Note that the `--json` output is always printed at the end so this should work
+    let json =
+      getLastJsonObjectFromString(stderr.toString()) ||
+      getLastJsonObjectFromString(stdout.toString());
+
+    if (json?.error) {
+      // The first case is no 2fa provided, the second is when the 2fa is wrong (timeout or wrong words)
+      if (
+        (json.error.code === "EOTP" ||
+          (json.error.code === "E401" &&
+            json.error.detail.includes("--otp=<code>"))) &&
+        !isCI
+      ) {
+        if (twoFactorState.token !== null) {
+          // the current otp code must be invalid since it errored
+          twoFactorState.token = null;
+        }
+        // just in case this isn't already true
+        twoFactorState.isRequired = Promise.resolve(true);
+        return internalPublish(pkgName, opts, twoFactorState);
+      }
+      error(
+        `an error occurred while publishing ${pkgName}: ${json.error.code}`,
+        json.error.summary,
+        json.error.detail ? "\n" + json.error.detail : ""
+      );
+    }
+
+    error(stderr.toString());
+    return { published: false };
+  }
+  return { published: true };
+}
+
+export function publish(
+  pkgName: string,
+  opts: { cwd: string; access?: string; tag: string },
+  twoFactorState: TwoFactorState
+): Promise<{ published: boolean }> {
+  // If there are many packages to be published, it's better to limit the
+  // concurrency to avoid unwanted errors, for example from npm.
+  return npmRequestLimit(() =>
+    npmPublishLimit(() => internalPublish(pkgName, opts, twoFactorState))
+  );
+}
diff --git a/node_modules/@changesets/cli/src/commands/publish/publishPackages.ts b/node_modules/@changesets/cli/src/commands/publish/publishPackages.ts
new file mode 100644
index 0000000..dd188e3
--- /dev/null
+++ b/node_modules/@changesets/cli/src/commands/publish/publishPackages.ts
@@ -0,0 +1,267 @@
+import { join } from "path";
+import semver from "semver";
+import chalk from "chalk";
+import * as git from "@changesets/git";
+import { AccessType } from "@changesets/types";
+import { Package } from "@manypkg/get-packages";
+import { info, warn } from "@changesets/logger";
+import { PreState } from "@changesets/types";
+import * as npmUtils from "./npm-utils";
+import { TwoFactorState } from "../../utils/types";
+import isCI from "is-ci";
+
+type PublishedState = "never" | "published" | "only-pre";
+
+type PkgInfo = {
+  name: string;
+  localVersion: string;
+  publishedState: PublishedState;
+  publishedVersions: string[];
+};
+
+type PublishedResult = {
+  name: string;
+  newVersion: string;
+  published: boolean;
+};
+
+function getReleaseTag(pkgInfo: PkgInfo, preState?: PreState, tag?: string) {
+  if (tag) return tag;
+
+  if (preState !== undefined && pkgInfo.publishedState !== "only-pre") {
+    return preState.tag;
+  }
+
+  return "latest";
+}
+
+const isCustomRegistry = (registry?: string): boolean =>
+  !!registry &&
+  registry !== "https://registry.npmjs.org" &&
+  registry !== "https://registry.yarnpkg.com";
+
+const getTwoFactorState = ({
+  otp,
+  publicPackages
+}: {
+  otp?: string;
+  publicPackages: Package[];
+}): TwoFactorState => {
+  if (otp) {
+    return {
+      token: otp,
+      isRequired: Promise.resolve(true)
+    };
+  }
+
+  if (
+    isCI ||
+    publicPackages.some(pkg =>
+      isCustomRegistry(pkg.packageJson.publishConfig?.registry)
+    ) ||
+    isCustomRegistry(process.env.npm_config_registry)
+  ) {
+    return {
+      token: null,
+      isRequired: Promise.resolve(false)
+    };
+  }
+
+  return {
+    token: null,
+    // note: we're not awaiting this here, we want this request to happen in parallel with getUnpublishedPackages
+    isRequired: npmUtils.getTokenIsRequired()
+  };
+};
+
+export default async function publishPackages({
+  packages,
+  access,
+  otp,
+  preState,
+  tag,
+  tagPrivatePackages
+}: {
+  packages: Package[];
+  access: AccessType;
+  otp?: string;
+  preState: PreState | undefined;
+  tag?: string;
+  tagPrivatePackages: boolean;
+}): Promise<{
+  publishedPackages: PublishedResult[];
+  untaggedPrivatePackages: Omit<PublishedResult, "published">[];
+}> {
+  const packagesByName = new Map(packages.map(x => [x.packageJson.name, x]));
+  const publicPackages = packages.filter(pkg => !pkg.packageJson.private);
+  const privatePackages = packages.filter(
+    pkg => pkg.packageJson.private && pkg.packageJson.version
+  );
+  const unpublishedPackagesInfo = await getUnpublishedPackages(
+    publicPackages,
+    preState
+  );
+
+  const twoFactorState: TwoFactorState =
+    unpublishedPackagesInfo.length > 0
+      ? getTwoFactorState({
+          otp,
+          publicPackages
+        })
+      : {
+          token: null,
+          isRequired: Promise.resolve(false)
+        };
+
+  const npmPackagePublish = Promise.all(
+    unpublishedPackagesInfo.map(pkgInfo => {
+      let pkg = packagesByName.get(pkgInfo.name)!;
+      return publishAPackage(
+        pkg,
+        access,
+        twoFactorState,
+        getReleaseTag(pkgInfo, preState, tag)
+      );
+    })
+  );
+
+  const untaggedPrivatePackageReleases = tagPrivatePackages
+    ? getUntaggedPrivatePackages(privatePackages)
+    : Promise.resolve([]);
+
+  const result: {
+    publishedPackages: PublishedResult[];
+    untaggedPrivatePackages: PublishedResult[];
+  } = {
+    publishedPackages: await npmPackagePublish,
+    untaggedPrivatePackages: await untaggedPrivatePackageReleases
+  };
+
+  if (
+    result.publishedPackages.length === 0 &&
+    result.untaggedPrivatePackages.length === 0
+  ) {
+    warn("No unpublished projects to publish");
+  }
+
+  return result;
+}
+
+async function getUntaggedPrivatePackages(privatePackages: Package[]) {
+  const packageWithTags = await Promise.all(
+    privatePackages.map(async privatePkg => {
+      const tagName = `${privatePkg.packageJson.name}@${privatePkg.packageJson.version}`;
+      const isMissingTag = !(await git.remoteTagExists(tagName));
+
+      return { pkg: privatePkg, isMissingTag };
+    })
+  );
+
+  const untagged: PublishedResult[] = [];
+
+  for (const packageWithTag of packageWithTags) {
+    if (packageWithTag.isMissingTag) {
+      untagged.push({
+        name: packageWithTag.pkg.packageJson.name,
+        newVersion: packageWithTag.pkg.packageJson.version,
+        published: false
+      });
+    }
+  }
+
+  return untagged;
+}
+
+async function publishAPackage(
+  pkg: Package,
+  access: AccessType,
+  twoFactorState: TwoFactorState,
+  tag: string
+): Promise<PublishedResult> {
+  const { name, version, publishConfig } = pkg.packageJson;
+  const localAccess = publishConfig?.access;
+  info(
+    `Publishing ${chalk.cyan(`"${name}"`)} at ${chalk.green(`"${version}"`)}`
+  );
+
+  const publishDir = publishConfig?.directory
+    ? join(pkg.dir, publishConfig.directory)
+    : pkg.dir;
+
+  const publishConfirmation = await npmUtils.publish(
+    name,
+    {
+      cwd: publishDir,
+      access: localAccess || access,
+      tag
+    },
+    twoFactorState
+  );
+
+  return {
+    name,
+    newVersion: version,
+    published: publishConfirmation.published
+  };
+}
+
+async function getUnpublishedPackages(
+  packages: Array<Package>,
+  preState: PreState | undefined
+) {
+  const results: Array<PkgInfo> = await Promise.all(
+    packages.map(async ({ packageJson }) => {
+      const response = await npmUtils.infoAllow404(packageJson);
+      let publishedState: PublishedState = "never";
+      if (response.published) {
+        publishedState = "published";
+        if (preState !== undefined) {
+          if (
+            response.pkgInfo.versions &&
+            response.pkgInfo.versions.every(
+              (version: string) =>
+                semver.parse(version)!.prerelease[0] === preState.tag
+            )
+          ) {
+            publishedState = "only-pre";
+          }
+        }
+      }
+
+      return {
+        name: packageJson.name,
+        localVersion: packageJson.version,
+        publishedState: publishedState,
+        publishedVersions: response.pkgInfo.versions || []
+      };
+    })
+  );
+
+  const packagesToPublish: Array<PkgInfo> = [];
+
+  for (const pkgInfo of results) {
+    const { name, publishedState, localVersion, publishedVersions } = pkgInfo;
+    if (!publishedVersions.includes(localVersion)) {
+      packagesToPublish.push(pkgInfo);
+      info(
+        `${name} is being published because our local version (${localVersion}) has not been published on npm`
+      );
+      if (preState !== undefined && publishedState === "only-pre") {
+        info(
+          `${name} is being published to ${chalk.cyan(
+            "latest"
+          )} rather than ${chalk.cyan(
+            preState.tag
+          )} because there has not been a regular release of it yet`
+        );
+      }
+    } else {
+      // If the local version is behind npm, something is wrong, we warn here, and by not getting published later, it will fail
+      warn(
+        `${name} is not being published because version ${localVersion} is already published on npm`
+      );
+    }
+  }
+
+  return packagesToPublish;
+}
diff --git a/node_modules/@changesets/cli/src/commands/status/__tests__/status.ts b/node_modules/@changesets/cli/src/commands/status/__tests__/status.ts
new file mode 100644
index 0000000..a661cad
--- /dev/null
+++ b/node_modules/@changesets/cli/src/commands/status/__tests__/status.ts
@@ -0,0 +1,163 @@
+import fixtures from "fixturez";
+import fs from "fs-extra";
+import path from "path";
+import * as git from "@changesets/git";
+import { defaultConfig } from "@changesets/config";
+import { silenceLogsInBlock } from "@changesets/test-utils";
+import writeChangeset from "@changesets/write";
+
+import status from "..";
+
+import humanId from "human-id";
+import { NewChangeset, ReleasePlan } from "@changesets/types";
+import { Package } from "@manypkg/get-packages";
+
+jest.mock("human-id");
+jest.mock("@changesets/git");
+
+const f = fixtures(__dirname);
+
+const simpleChangeset: NewChangeset = {
+  id: "fake-ids-abound",
+  summary: "This is a summary",
+  releases: [
+    { name: "pkg-a", type: "minor" },
+    { name: "pkg-b", type: "patch" }
+  ]
+};
+
+const simpleReleasePlan: ReleasePlan = {
+  releases: [
+    {
+      name: "pkg-a",
+      type: "minor",
+      changesets: ["ascii"],
+      oldVersion: "1.0.0",
+      newVersion: "1.1.0"
+    },
+    {
+      name: "pkg-b",
+      type: "patch",
+      changesets: ["ascii"],
+      oldVersion: "1.0.0",
+      newVersion: "1.0.1"
+    }
+  ],
+  changesets: [
+    {
+      summary: "This is a summary",
+      releases: [
+        { name: "pkg-a", type: "minor" },
+        { name: "pkg-b", type: "patch" }
+      ],
+      id: "ascii"
+    }
+  ],
+  preState: undefined
+};
+
+const simpleChangedPackagesList: Package[] = [
+  {
+    packageJson: { name: "pkg-a", version: "1.0.0", dependencies: {} },
+    dir: "/fake/folder/doesnt/matter"
+  },
+  {
+    packageJson: { name: "pkg-b", version: "1.0.0" },
+    dir: "/fake/folder/doesnt/matter"
+  }
+];
+
+const writeChangesets = (changesets: NewChangeset[], cwd: string) => {
+  return Promise.all(changesets.map(commit => writeChangeset(commit, cwd)));
+};
+
+describe("status", () => {
+  silenceLogsInBlock();
+  let cwd: string;
+
+  beforeEach(async () => {
+    cwd = await f.copy("simple-project");
+  });
+
+  it("should get the status for a simple changeset and return the release object", async () => {
+    const changesetID = "ascii";
+    // @ts-ignore
+    humanId.mockReturnValueOnce(changesetID);
+    // @ts-ignore
+    git.getChangedPackagesSinceRef.mockImplementation(
+      () => simpleChangedPackagesList
+    );
+
+    await writeChangesets([simpleChangeset], cwd);
+    const releaseObj = await status(cwd, {}, defaultConfig);
+    expect(releaseObj).toEqual(simpleReleasePlan);
+  });
+
+  it("should exit early with a non-zero error code when there are changed packages but no changesets", async () => {
+    // @ts-ignore
+    jest.spyOn(process, "exit").mockImplementation(() => {});
+    // @ts-ignore
+    git.getChangedPackagesSinceRef.mockImplementation(
+      () => simpleChangedPackagesList
+    );
+
+    await status(cwd, {}, defaultConfig);
+
+    expect(process.exit).toHaveBeenCalledWith(1);
+  });
+
+  it("should not exit early with a non-zero error code when there are no changed packages", async () => {
+    // @ts-ignore
+    jest.spyOn(process, "exit").mockImplementation(() => {});
+    // @ts-ignore
+    git.getChangedPackagesSinceRef.mockImplementation(() => []);
+
+    const releaseObj = await status(cwd, {}, defaultConfig);
+
+    expect(process.exit).not.toHaveBeenCalled();
+    expect(releaseObj).toEqual({
+      changesets: [],
+      releases: [],
+      preState: undefined
+    });
+  });
+
+  it("should not exit early with a non-zero code when there are changed packages and also a changeset", async () => {
+    // @ts-ignore
+    jest.spyOn(process, "exit").mockImplementation(() => {});
+    // @ts-ignore
+    git.getChangedPackagesSinceRef.mockImplementation(
+      () => simpleChangedPackagesList
+    );
+    const changesetID = "ascii";
+    // @ts-ignore
+    humanId.mockReturnValueOnce(changesetID);
+
+    await writeChangesets([simpleChangeset], cwd);
+    const releaseObj = await status(cwd, {}, defaultConfig);
+
+    expect(releaseObj).toEqual(simpleReleasePlan);
+    expect(process.exit).not.toHaveBeenCalled();
+  });
+
+  it.skip("should respect the verbose flag", () => false);
+  it("should respect the output flag", async () => {
+    const output = "nonsense.json";
+
+    // @ts-ignore
+    git.getChangedPackagesSinceRef.mockImplementation(
+      () => simpleChangedPackagesList
+    );
+    const changesetID = "ascii";
+    // @ts-ignore
+    humanId.mockReturnValueOnce(changesetID);
+
+    await writeChangesets([simpleChangeset], cwd);
+    const probsUndefined = await status(cwd, { output }, defaultConfig);
+
+    const releaseObj = await fs.readFile(path.join(cwd, output), "utf-8");
+
+    expect(probsUndefined).toEqual(undefined);
+    expect(JSON.parse(releaseObj)).toEqual(simpleReleasePlan);
+  });
+});
diff --git a/node_modules/@changesets/cli/src/commands/status/index.ts b/node_modules/@changesets/cli/src/commands/status/index.ts
new file mode 100644
index 0000000..81530d5
--- /dev/null
+++ b/node_modules/@changesets/cli/src/commands/status/index.ts
@@ -0,0 +1,117 @@
+import chalk from "chalk";
+import table from "tty-table";
+import fs from "fs-extra";
+import path from "path";
+
+import * as git from "@changesets/git";
+import getReleasePlan from "@changesets/get-release-plan";
+import { error, log, info, warn } from "@changesets/logger";
+import {
+  VersionType,
+  Release,
+  ComprehensiveRelease,
+  Config
+} from "@changesets/types";
+
+export default async function getStatus(
+  cwd: string,
+  {
+    sinceMaster,
+    since,
+    verbose,
+    output
+  }: {
+    sinceMaster?: boolean;
+    since?: string;
+    verbose?: boolean;
+    output?: string;
+  },
+  config: Config
+) {
+  if (sinceMaster) {
+    warn(
+      "--sinceMaster is deprecated and will be removed in a future major version"
+    );
+    warn("Use --since=master instead");
+  }
+  const sinceBranch =
+    since === undefined ? (sinceMaster ? "master" : undefined) : since;
+  const releasePlan = await getReleasePlan(cwd, sinceBranch, config);
+  const { changesets, releases } = releasePlan;
+  const changedPackages = await git.getChangedPackagesSinceRef({
+    cwd,
+    ref: sinceBranch || config.baseBranch
+  });
+
+  if (changedPackages.length > 0 && changesets.length === 0) {
+    error(
+      "Some packages have been changed but no changesets were found. Run `changeset add` to resolve this error."
+    );
+    error(
+      "If this change doesn't need a release, run `changeset add --empty`."
+    );
+    process.exit(1);
+  }
+
+  if (output) {
+    await fs.writeFile(
+      path.join(cwd, output),
+      JSON.stringify(releasePlan, undefined, 2)
+    );
+    return;
+  }
+
+  const print = verbose ? verbosePrint : SimplePrint;
+  print("patch", releases);
+  log("---");
+  print("minor", releases);
+  log("---");
+  print("major", releases);
+
+  return releasePlan;
+}
+
+function SimplePrint(type: VersionType, releases: Array<Release>) {
+  const packages = releases.filter(r => r.type === type);
+  if (packages.length) {
+    info(chalk`Packages to be bumped at {green ${type}}:\n`);
+
+    const pkgs = packages.map(({ name }) => `- ${name}`).join("\n");
+    log(chalk.green(pkgs));
+  } else {
+    info(chalk`{red NO} packages to be bumped at {green ${type}}`);
+  }
+}
+
+function verbosePrint(
+  type: VersionType,
+  releases: Array<ComprehensiveRelease>
+) {
+  const packages = releases.filter(r => r.type === type);
+  if (packages.length) {
+    info(chalk`Packages to be bumped at {green ${type}}`);
+
+    const columns = packages.map(
+      ({ name, newVersion: version, changesets }) => [
+        chalk.green(name),
+        version,
+        changesets.map(c => chalk.blue(` .changeset/${c}.md`)).join(" +")
+      ]
+    );
+
+    const t1 = table(
+      [
+        { value: "Package Name", width: 20 },
+        { value: "New Version", width: 20 },
+        { value: "Related Changeset Summaries", width: 70 }
+      ],
+      columns,
+      { paddingLeft: 1, paddingRight: 0, headerAlign: "center", align: "left" }
+    );
+    log(t1.render() + "\n");
+  } else {
+    info(
+      chalk`Running release would release {red NO} packages as a {green ${type}}`
+    );
+  }
+}
diff --git a/node_modules/@changesets/cli/src/commands/tag/__tests__/index.test.ts b/node_modules/@changesets/cli/src/commands/tag/__tests__/index.test.ts
new file mode 100644
index 0000000..117c6e9
--- /dev/null
+++ b/node_modules/@changesets/cli/src/commands/tag/__tests__/index.test.ts
@@ -0,0 +1,58 @@
+import fixtures from "fixturez";
+import { silenceLogsInBlock } from "../../../../../test-utils/src";
+import * as git from "@changesets/git";
+import tag from "../index";
+
+const f = fixtures(__dirname);
+
+jest.mock("@changesets/git");
+
+describe("tag command", () => {
+  silenceLogsInBlock();
+  let cwd: string;
+
+  describe("workspace project", () => {
+    beforeEach(async () => {
+      cwd = await f.copy("simple-project");
+    });
+
+    it("tags all packages", async () => {
+      (git.getAllTags as jest.Mock).mockReturnValue(new Set());
+
+      expect(git.tag).not.toHaveBeenCalled();
+      await tag(cwd);
+      expect(git.tag).toHaveBeenCalledTimes(2);
+      expect((git.tag as jest.Mock).mock.calls[0][0]).toEqual("pkg-a@1.0.0");
+      expect((git.tag as jest.Mock).mock.calls[1][0]).toEqual("pkg-b@1.0.0");
+    });
+
+    it("skips tags that already exist", async () => {
+      (git.getAllTags as jest.Mock).mockReturnValue(
+        new Set([
+          // pkg-a should not be re-tagged
+          "pkg-a@1.0.0"
+        ])
+      );
+
+      expect(git.tag).not.toHaveBeenCalled();
+      await tag(cwd);
+      expect(git.tag).toHaveBeenCalledTimes(1);
+      expect((git.tag as jest.Mock).mock.calls[0][0]).toEqual("pkg-b@1.0.0");
+    });
+  });
+
+  describe("single package repo", () => {
+    beforeEach(async () => {
+      cwd = await f.copy("root-only");
+    });
+
+    it("uses a simplified version-only tag", async () => {
+      (git.getAllTags as jest.Mock).mockReturnValue(new Set());
+
+      expect(git.tag).not.toHaveBeenCalled();
+      await tag(cwd);
+      expect(git.tag).toHaveBeenCalledTimes(1);
+      expect((git.tag as jest.Mock).mock.calls[0][0]).toEqual("v1.0.0");
+    });
+  });
+});
diff --git a/node_modules/@changesets/cli/src/commands/tag/index.ts b/node_modules/@changesets/cli/src/commands/tag/index.ts
new file mode 100644
index 0000000..d545033
--- /dev/null
+++ b/node_modules/@changesets/cli/src/commands/tag/index.ts
@@ -0,0 +1,23 @@
+import * as git from "@changesets/git";
+import { getPackages } from "@manypkg/get-packages";
+import { log } from "@changesets/logger";
+
+export default async function run(cwd: string) {
+  const { packages, tool } = await getPackages(cwd);
+
+  const allExistingTags = await git.getAllTags(cwd);
+
+  for (const pkg of packages) {
+    const tag =
+      tool !== "root"
+        ? `${pkg.packageJson.name}@${pkg.packageJson.version}`
+        : `v${pkg.packageJson.version}`;
+
+    if (allExistingTags.has(tag)) {
+      log("Skipping tag (already exists): ", tag);
+    } else {
+      log("New tag: ", tag);
+      await git.tag(tag, cwd);
+    }
+  }
+}
diff --git a/node_modules/@changesets/cli/src/commands/version/index.ts b/node_modules/@changesets/cli/src/commands/version/index.ts
new file mode 100644
index 0000000..308435a
--- /dev/null
+++ b/node_modules/@changesets/cli/src/commands/version/index.ts
@@ -0,0 +1,110 @@
+import chalk from "chalk";
+import path from "path";
+import * as git from "@changesets/git";
+import { log, warn, error } from "@changesets/logger";
+import { Config } from "@changesets/types";
+import applyReleasePlan from "@changesets/apply-release-plan";
+import readChangesets from "@changesets/read";
+import assembleReleasePlan from "@changesets/assemble-release-plan";
+import { getPackages } from "@manypkg/get-packages";
+
+import { removeEmptyFolders } from "../../utils/v1-legacy/removeFolders";
+import { readPreState } from "@changesets/pre";
+import { ExitError } from "@changesets/errors";
+import { getCommitFunctions } from "../../commit/getCommitFunctions";
+
+let importantSeparator = chalk.red(
+  "===============================IMPORTANT!==============================="
+);
+
+let importantEnd = chalk.red(
+  "----------------------------------------------------------------------"
+);
+
+export default async function version(
+  cwd: string,
+  options: {
+    snapshot?: string | boolean;
+  },
+  config: Config
+) {
+  const releaseConfig = {
+    ...config,
+    // Disable committing when in snapshot mode
+    commit: options.snapshot ? false : config.commit
+  };
+  const [changesets, preState] = await Promise.all([
+    readChangesets(cwd),
+    readPreState(cwd),
+    removeEmptyFolders(path.resolve(cwd, ".changeset"))
+  ]);
+
+  if (preState?.mode === "pre") {
+    warn(importantSeparator);
+    if (options.snapshot !== undefined) {
+      error("Snapshot release is not allowed in pre mode");
+      log("To resolve this exit the pre mode by running `changeset pre exit`");
+      throw new ExitError(1);
+    } else {
+      warn("You are in prerelease mode");
+      warn(
+        "If you meant to do a normal release you should revert these changes and run `changeset pre exit`"
+      );
+      warn("You can then run `changeset version` again to do a normal release");
+    }
+    warn(importantEnd);
+  }
+
+  if (
+    changesets.length === 0 &&
+    (preState === undefined || preState.mode !== "exit")
+  ) {
+    warn("No unreleased changesets found, exiting.");
+    return;
+  }
+
+  let packages = await getPackages(cwd);
+
+  let releasePlan = assembleReleasePlan(
+    changesets,
+    packages,
+    releaseConfig,
+    preState,
+    options.snapshot
+  );
+
+  let [...touchedFiles] = await applyReleasePlan(
+    releasePlan,
+    packages,
+    releaseConfig,
+    options.snapshot
+  );
+
+  const [{ getVersionMessage }, commitOpts] = getCommitFunctions(
+    releaseConfig.commit,
+    cwd
+  );
+  if (getVersionMessage) {
+    let touchedFile: string | undefined;
+    // Note, git gets angry if you try and have two git actions running at once
+    // So we need to be careful that these iterations are properly sequential
+    while ((touchedFile = touchedFiles.shift())) {
+      await git.add(path.relative(cwd, touchedFile), cwd);
+    }
+
+    const commit = await git.commit(
+      await getVersionMessage(releasePlan, commitOpts),
+      cwd
+    );
+
+    if (!commit) {
+      error("Changesets ran into trouble committing your files");
+    } else {
+      log(
+        "All files have been updated and committed. You're ready to publish!"
+      );
+    }
+  } else {
+    log("All files have been updated. Review them and commit at your leisure");
+  }
+}
diff --git a/node_modules/@changesets/cli/src/commands/version/version.test.ts b/node_modules/@changesets/cli/src/commands/version/version.test.ts
new file mode 100644
index 0000000..cf58af3
--- /dev/null
+++ b/node_modules/@changesets/cli/src/commands/version/version.test.ts
@@ -0,0 +1,1881 @@
+import fixtures from "fixturez";
+
+import fs from "fs-extra";
+import path from "path";
+import * as git from "@changesets/git";
+import { warn } from "@changesets/logger";
+import { silenceLogsInBlock } from "@changesets/test-utils";
+import writeChangeset from "@changesets/write";
+import { NewChangeset, Config } from "@changesets/types";
+import { defaultConfig } from "@changesets/config";
+import { getPackages } from "@manypkg/get-packages";
+import pre from "../pre";
+import version from "./index";
+import humanId from "human-id";
+
+const f = fixtures(__dirname);
+
+let changelogPath = path.resolve(__dirname, "../../changelog");
+let commitPath = path.resolve(__dirname, "../../commit");
+let modifiedDefaultConfig: Config = {
+  ...defaultConfig,
+  changelog: [changelogPath, null]
+};
+
+let defaultOptions = {
+  snapshot: undefined
+};
+
+// avoid polluting test logs with error message in console
+// This is from bolt's error log
+const consoleError = console.error;
+
+jest.mock("../../utils/cli-utilities");
+jest.mock("@changesets/git");
+jest.mock("human-id");
+jest.mock("@changesets/logger");
+
+// @ts-ignore
+git.add.mockImplementation(() => Promise.resolve(true));
+// @ts-ignore
+git.commit.mockImplementation(() => Promise.resolve(true));
+// @ts-ignore
+git.getCommitsThatAddFiles.mockImplementation(changesetIds =>
+  Promise.resolve(changesetIds.map(() => "g1th4sh"))
+);
+// @ts-ignore
+git.tag.mockImplementation(() => Promise.resolve(true));
+
+const simpleChangeset: NewChangeset = {
+  summary: "This is a summary",
+  releases: [{ name: "pkg-a", type: "minor" }],
+  id: "having-lotsof-fun"
+};
+
+const simpleChangeset2: NewChangeset = {
+  summary: "This is a summary too",
+  releases: [
+    { name: "pkg-a", type: "minor" },
+    { name: "pkg-b", type: "patch" }
+  ],
+  id: "wouldnit-be-nice"
+};
+
+const simpleChangeset3: NewChangeset = {
+  summary: "This is not a summary",
+  releases: [{ name: "pkg-b", type: "patch" }],
+  id: "hot-day-today"
+};
+
+const writeChangesets = (changesets: NewChangeset[], cwd: string) => {
+  return Promise.all(
+    changesets.map(changeset => writeChangeset(changeset, cwd))
+  );
+};
+
+const getFile = (pkgName: string, fileName: string, calls: any) => {
+  let castCalls: [string, string][] = calls;
+  const foundCall = castCalls.find(call =>
+    call[0].endsWith(`${pkgName}${path.sep}${fileName}`)
+  );
+  if (!foundCall)
+    throw new Error(`could not find writing of ${fileName} for: ${pkgName}`);
+
+  // return written content
+  return foundCall[1];
+};
+
+const getPkgJSON = (pkgName: string, calls: any) => {
+  return JSON.parse(getFile(pkgName, "package.json", calls));
+};
+
+const getChangelog = (pkgName: string, calls: any) => {
+  return getFile(pkgName, "CHANGELOG.md", calls);
+};
+
+const writeEmptyChangeset = (cwd: string) => writeChangesets([], cwd);
+
+beforeEach(() => {
+  let i = 0;
+  (humanId as jest.Mock<string, []>).mockImplementation(() => {
+    return `some-id-${i++}`;
+  });
+
+  console.error = jest.fn();
+});
+
+afterEach(() => {
+  console.error = consoleError;
+});
+
+describe("running version in a simple project", () => {
+  silenceLogsInBlock();
+  let cwd: string;
+
+  beforeEach(async () => {
+    cwd = await f.copy("simple-project");
+    console.error = jest.fn();
+  });
+
+  afterEach(async () => {
+    console.error = consoleError;
+  });
+
+  describe("when there are no changeset commits", () => {
+    it("should warn if no changeset commits exist", async () => {
+      await writeEmptyChangeset(cwd);
+      await version(cwd, defaultOptions, modifiedDefaultConfig);
+      // @ts-ignore
+      const loggerWarnCalls = warn.mock.calls;
+      expect(loggerWarnCalls.length).toEqual(1);
+      expect(loggerWarnCalls[0][0]).toEqual(
+        "No unreleased changesets found, exiting."
+      );
+    });
+  });
+
+  describe("when there is a changeset commit", () => {
+    it("should bump releasedPackages", async () => {
+      await writeChangesets([simpleChangeset2], cwd);
+      const spy = jest.spyOn(fs, "writeFile");
+
+      await version(cwd, defaultOptions, modifiedDefaultConfig);
+
+      expect(getPkgJSON("pkg-a", spy.mock.calls)).toEqual(
+        expect.objectContaining({ name: "pkg-a", version: "1.1.0" })
+      );
+      expect(getPkgJSON("pkg-b", spy.mock.calls)).toEqual(
+        expect.objectContaining({ name: "pkg-b", version: "1.0.1" })
+      );
+    });
+  });
+
+  it("should not touch package.json of an ignored package when it is not a dependent of any releasedPackages ", async () => {
+    await writeChangesets([simpleChangeset], cwd);
+    const spy = jest.spyOn(fs, "writeFile");
+
+    await version(cwd, defaultOptions, {
+      ...modifiedDefaultConfig,
+      ignore: ["pkg-a"]
+    });
+
+    const bumpedPackageA = !!spy.mock.calls.find((call: string[]) =>
+      call[0].endsWith(`pkg-a${path.sep}package.json`)
+    );
+
+    expect(bumpedPackageA).toBe(false);
+  });
+
+  it("should not bump ignored packages", async () => {
+    await writeChangesets([simpleChangeset, simpleChangeset3], cwd);
+
+    await version(cwd, defaultOptions, {
+      ...modifiedDefaultConfig,
+      ignore: ["pkg-a"]
+    });
+
+    expect((await getPackages(cwd)).packages.map(x => x.packageJson))
+      .toMatchInlineSnapshot(`
+      Array [
+        Object {
+          "dependencies": Object {
+            "pkg-b": "1.0.1",
+          },
+          "name": "pkg-a",
+          "version": "1.0.0",
+        },
+        Object {
+          "name": "pkg-b",
+          "version": "1.0.1",
+        },
+      ]
+    `);
+  });
+
+  it("should not commit the result if commit config is not set", async () => {
+    await writeChangesets([simpleChangeset2], cwd);
+    const spy = jest.spyOn(git, "commit");
+
+    expect(spy).not.toHaveBeenCalled();
+
+    await version(cwd, defaultOptions, modifiedDefaultConfig);
+
+    expect(spy).not.toHaveBeenCalled();
+  });
+
+  it("should git add the expected files if commit config is set", async () => {
+    const ids = await writeChangesets([simpleChangeset2], cwd);
+    const spy = jest.spyOn(git, "add");
+
+    expect(spy).not.toHaveBeenCalled();
+
+    await version(cwd, defaultOptions, {
+      ...modifiedDefaultConfig,
+      commit: [commitPath, null]
+    });
+
+    expect(spy).toHaveBeenCalled();
+
+    expect(spy).toHaveBeenCalledWith("packages/pkg-a/package.json", cwd);
+    expect(spy).toHaveBeenCalledWith("packages/pkg-a/CHANGELOG.md", cwd);
+
+    expect(spy).toHaveBeenCalledWith("packages/pkg-b/package.json", cwd);
+    expect(spy).toHaveBeenCalledWith("packages/pkg-b/CHANGELOG.md", cwd);
+
+    expect(spy).toHaveBeenCalledWith(`.changeset/${ids[0]}.md`, cwd);
+  });
+
+  it("should commit the result if commit config is set", async () => {
+    await writeChangesets([simpleChangeset2], cwd);
+    const spy = jest.spyOn(git, "commit");
+
+    expect(spy).not.toHaveBeenCalled();
+
+    await version(cwd, defaultOptions, {
+      ...modifiedDefaultConfig,
+      commit: [commitPath, null]
+    });
+
+    expect(spy).toHaveBeenCalled();
+    expect(spy.mock.calls[0][0]).toMatchInlineSnapshot(`
+      "RELEASING: Releasing 2 package(s)
+
+      Releases:
+        pkg-a@1.1.0
+        pkg-b@1.0.1
+      "
+    `);
+  });
+
+  it("should skip over ignored changesets", async () => {
+    const cwd = await f.copy("ignored-changeset");
+
+    await version(cwd, defaultOptions, modifiedDefaultConfig);
+
+    let packages = await getPackages(cwd);
+    expect(packages.packages.map(x => x.packageJson)).toEqual([
+      {
+        name: "pkg-a",
+        version: "1.1.0",
+        dependencies: {
+          "pkg-b": "1.0.0"
+        }
+      },
+      {
+        name: "pkg-b",
+        version: "1.0.0"
+      }
+    ]);
+
+    const changesetDir = await fs.readdir(path.join(cwd, ".changeset"));
+    // should still contain the ignored changeset
+    expect(changesetDir).toContain(".ignored-temporarily.md");
+  });
+
+  it("should not update a dependant that uses a tag as a dependency rage for a package that could otherwise be local", async () => {
+    const cwd = await f.copy("dependant-with-tag-range");
+
+    await writeChangeset(
+      {
+        releases: [{ name: "pkg-a", type: "major" }],
+        summary: "a very useful summary for the change"
+      },
+      cwd
+    );
+
+    await version(cwd, defaultOptions, modifiedDefaultConfig);
+
+    expect((await getPackages(cwd)).packages.map(x => x.packageJson))
+      .toMatchInlineSnapshot(`
+      Array [
+        Object {
+          "dependencies": Object {
+            "pkg-a": "latest",
+          },
+          "name": "example-a",
+          "version": "1.0.0",
+        },
+        Object {
+          "name": "pkg-a",
+          "version": "2.0.0",
+        },
+      ]
+    `);
+  });
+
+  describe("when there are multiple changeset commits", () => {
+    it("should bump releasedPackages", async () => {
+      await writeChangesets([simpleChangeset, simpleChangeset2], cwd);
+      const spy = jest.spyOn(fs, "writeFile");
+
+      await version(cwd, defaultOptions, modifiedDefaultConfig);
+
+      expect(getPkgJSON("pkg-a", spy.mock.calls)).toEqual(
+        expect.objectContaining({ name: "pkg-a", version: "1.1.0" })
+      );
+      expect(getPkgJSON("pkg-b", spy.mock.calls)).toEqual(
+        expect.objectContaining({ name: "pkg-b", version: "1.0.1" })
+      );
+    });
+
+    it("should bump multiple released packages if required", async () => {
+      await writeChangesets([simpleChangeset, simpleChangeset2], cwd);
+      const spy = jest.spyOn(fs, "writeFile");
+      await version(cwd, defaultOptions, modifiedDefaultConfig);
+
+      // first call should be minor bump
+      expect(getPkgJSON("pkg-a", spy.mock.calls)).toEqual(
+        expect.objectContaining({
+          name: "pkg-a",
+          version: "1.1.0"
+        })
+      );
+      // second should be a patch
+      expect(getPkgJSON("pkg-b", spy.mock.calls)).toEqual(
+        expect.objectContaining({
+          name: "pkg-b",
+          version: "1.0.1"
+        })
+      );
+    });
+    it("should delete the changeset files", async () => {
+      await writeChangesets([simpleChangeset, simpleChangeset2], cwd);
+      await version(cwd, defaultOptions, modifiedDefaultConfig);
+
+      const files = await fs.readdir(path.resolve(cwd, ".changeset"));
+      expect(files.length).toBe(2);
+    });
+  });
+});
+
+describe("fixed", () => {
+  it("should bump packages to the correct versions when packages are fixed", async () => {
+    const cwd = await f.copy("fixed-packages");
+    await writeChangesets([simpleChangeset], cwd);
+    const spy = jest.spyOn(fs, "writeFile");
+
+    await version(cwd, defaultOptions, {
+      ...modifiedDefaultConfig,
+      fixed: [["pkg-a", "pkg-b"]]
+    });
+
+    expect(getPkgJSON("pkg-a", spy.mock.calls)).toEqual(
+      expect.objectContaining({ name: "pkg-a", version: "1.1.0" })
+    );
+    expect(getPkgJSON("pkg-b", spy.mock.calls)).toEqual(
+      expect.objectContaining({ name: "pkg-b", version: "1.1.0" })
+    );
+  });
+
+  it("should not bump an ignored fixed package that depends on a package from the group that is being released", async () => {
+    const cwd = await f.copy("fixed-packages");
+    await writeChangesets([simpleChangeset3], cwd);
+
+    await version(cwd, defaultOptions, {
+      ...modifiedDefaultConfig,
+      fixed: [["pkg-a", "pkg-b"]],
+      ignore: ["pkg-a"]
+    });
+
+    expect((await getPackages(cwd)).packages.map(x => x.packageJson))
+      .toMatchInlineSnapshot(`
+      Array [
+        Object {
+          "dependencies": Object {
+            "pkg-b": "1.0.1",
+          },
+          "name": "pkg-a",
+          "version": "1.0.0",
+        },
+        Object {
+          "name": "pkg-b",
+          "version": "1.0.1",
+        },
+      ]
+    `);
+  });
+
+  it("should update CHANGELOGs of all packages from the fixed group", async () => {
+    const cwd = await f.copy("fixed-packages");
+    const spy = jest.spyOn(fs, "writeFile");
+
+    await writeChangesets([simpleChangeset], cwd);
+
+    await version(cwd, defaultOptions, {
+      ...modifiedDefaultConfig,
+      fixed: [["pkg-a", "pkg-b"]]
+    });
+
+    expect(getChangelog("pkg-a", spy.mock.calls)).toMatchInlineSnapshot(`
+      "# pkg-a
+
+      ## 1.1.0
+
+      ### Minor Changes
+
+      - g1th4sh: This is a summary
+
+      ### Patch Changes
+
+      - pkg-b@1.1.0
+      "
+    `);
+    expect(getChangelog("pkg-b", spy.mock.calls)).toMatchInlineSnapshot(`
+      "# pkg-b
+
+      ## 1.1.0
+      "
+    `);
+
+    spy.mockClear();
+
+    await writeChangesets([simpleChangeset], cwd);
+
+    await version(cwd, defaultOptions, {
+      ...modifiedDefaultConfig,
+      fixed: [["pkg-a", "pkg-b"]]
+    });
+
+    expect(getChangelog("pkg-a", spy.mock.calls)).toMatchInlineSnapshot(`
+      "# pkg-a
+
+      ## 1.2.0
+
+      ### Minor Changes
+
+      - g1th4sh: This is a summary
+
+      ### Patch Changes
+
+      - pkg-b@1.2.0
+
+      ## 1.1.0
+
+      ### Minor Changes
+
+      - g1th4sh: This is a summary
+
+      ### Patch Changes
+
+      - pkg-b@1.1.0
+      "
+    `);
+    expect(getChangelog("pkg-b", spy.mock.calls)).toMatchInlineSnapshot(`
+      "# pkg-b
+
+      ## 1.2.0
+
+      ## 1.1.0
+      "
+    `);
+  });
+});
+
+describe("linked", () => {
+  it("should bump packages to the correct versions when packages are linked", async () => {
+    const cwd = await f.copy("linked-packages");
+    await writeChangesets([simpleChangeset2], cwd);
+    const spy = jest.spyOn(fs, "writeFile");
+
+    await version(cwd, defaultOptions, {
+      ...modifiedDefaultConfig,
+      linked: [["pkg-a", "pkg-b"]]
+    });
+
+    expect(getPkgJSON("pkg-a", spy.mock.calls)).toEqual(
+      expect.objectContaining({ name: "pkg-a", version: "1.1.0" })
+    );
+    expect(getPkgJSON("pkg-b", spy.mock.calls)).toEqual(
+      expect.objectContaining({ name: "pkg-b", version: "1.1.0" })
+    );
+  });
+
+  it("should not break when there is a linked package without a changeset", async () => {
+    const cwd = await f.copy("linked-packages");
+    await writeChangesets([simpleChangeset], cwd);
+    const spy = jest.spyOn(fs, "writeFile");
+
+    await version(cwd, defaultOptions, modifiedDefaultConfig);
+
+    expect(getPkgJSON("pkg-a", spy.mock.calls)).toEqual(
+      expect.objectContaining({ name: "pkg-a", version: "1.1.0" })
+    );
+  });
+});
+
+describe("workspace range", () => {
+  it("should update dependency range correctly", async () => {
+    const cwd = f.copy("simple-workspace-range-dep");
+
+    await writeChangesets([simpleChangeset2], cwd);
+    await version(cwd, defaultOptions, modifiedDefaultConfig);
+
+    let packages = await getPackages(cwd);
+    expect(packages.packages.map(x => x.packageJson)).toEqual([
+      {
+        name: "pkg-a",
+        version: "1.1.0",
+        dependencies: {
+          "pkg-b": "workspace:1.0.1"
+        }
+      },
+      {
+        name: "pkg-b",
+        version: "1.0.1"
+      }
+    ]);
+  });
+
+  it("should bump dependent package when bumping a `workspace:*` dependency", async () => {
+    const cwd = f.copy("simple-workspace-wildcard-range-dep");
+
+    await writeChangeset(
+      {
+        releases: [{ name: "pkg-b", type: "patch" }],
+        summary: "a very useful summary for the change"
+      },
+      cwd
+    );
+    await version(cwd, defaultOptions, modifiedDefaultConfig);
+
+    let packages = await getPackages(cwd);
+    expect(packages.packages.map(x => x.packageJson)).toEqual([
+      {
+        name: "pkg-a",
+        version: "1.0.1",
+        dependencies: {
+          "pkg-b": "workspace:*"
+        }
+      },
+      {
+        name: "pkg-b",
+        version: "1.0.1"
+      }
+    ]);
+  });
+
+  it("should bump dependent package when bumping a `workspace:^` dependency", async () => {
+    const cwd = f.copy("workspace-alias-range-dep");
+
+    await writeChangeset(
+      {
+        releases: [{ name: "pkg-b", type: "patch" }],
+        summary: "a very useful summary for the change"
+      },
+      cwd
+    );
+    await version(cwd, defaultOptions, modifiedDefaultConfig);
+
+    let packages = await getPackages(cwd);
+    expect(packages.packages.map(x => x.packageJson)).toEqual([
+      {
+        name: "pkg-a",
+        version: "1.0.1",
+        dependencies: {
+          "pkg-b": "workspace:^",
+          "pkg-c": "workspace:~"
+        }
+      },
+      {
+        name: "pkg-b",
+        version: "1.0.1"
+      },
+      {
+        name: "pkg-c",
+        version: "1.0.0"
+      }
+    ]);
+  });
+});
+
+describe("same package in different dependency types", () => {
+  it("should update different range types correctly", async () => {
+    let cwd = f.copy("simple-project-same-dep-diff-range");
+    await writeChangeset(
+      {
+        releases: [
+          {
+            name: "pkg-b",
+            type: "patch"
+          }
+        ],
+        summary: "a very useful summary for the first change"
+      },
+      cwd
+    );
+
+    await version(cwd, defaultOptions, modifiedDefaultConfig);
+
+    let packages = (await getPackages(cwd))!;
+    expect(packages.packages.map(x => x.packageJson)).toEqual([
+      {
+        devDependencies: {
+          "pkg-b": "1.0.1"
+        },
+        peerDependencies: {
+          "pkg-b": "^1.0.1"
+        },
+        name: "pkg-a",
+        version: "1.0.0"
+      },
+      {
+        name: "pkg-b",
+        version: "1.0.1"
+      }
+    ]);
+  });
+});
+
+describe("snapshot release", () => {
+  it("should update the package to unique version no matter the kind of version bump it is", async () => {
+    let cwd = f.copy("simple-project");
+    await writeChangesets([simpleChangeset2], cwd);
+    const spy = jest.spyOn(fs, "writeFile");
+    await version(
+      cwd,
+      {
+        snapshot: "experimental"
+      },
+      {
+        ...modifiedDefaultConfig,
+        commit: false
+      }
+    );
+    expect(getPkgJSON("pkg-a", spy.mock.calls)).toEqual(
+      expect.objectContaining({
+        name: "pkg-a",
+        version: expect.stringContaining("0.0.0-experimental-")
+      })
+    );
+
+    expect(getPkgJSON("pkg-b", spy.mock.calls)).toEqual(
+      expect.objectContaining({
+        name: "pkg-b",
+        version: expect.stringContaining("0.0.0-experimental-")
+      })
+    );
+  });
+
+  it("should not commit the result even if commit config is set", async () => {
+    let cwd = f.copy("simple-project");
+    await writeChangesets([simpleChangeset2], cwd);
+    const spy = jest.spyOn(git, "commit");
+
+    expect(spy).not.toHaveBeenCalled();
+
+    await version(
+      cwd,
+      {
+        snapshot: "experimental"
+      },
+      {
+        ...modifiedDefaultConfig,
+        commit: [commitPath, null]
+      }
+    );
+
+    expect(spy).not.toHaveBeenCalled();
+  });
+
+  it("should not bump version of a package with an explicit none release type", async () => {
+    const cwd = await f.copy("simple-project");
+    await writeChangeset(
+      {
+        releases: [{ name: "pkg-a", type: "none" }],
+        summary: "some internal stuff"
+      },
+      cwd
+    );
+
+    await version(
+      cwd,
+      {
+        snapshot: true
+      },
+      modifiedDefaultConfig
+    );
+
+    expect((await getPackages(cwd)).packages.map(x => x.packageJson))
+      .toMatchInlineSnapshot(`
+      Array [
+        Object {
+          "dependencies": Object {
+            "pkg-b": "1.0.0",
+          },
+          "name": "pkg-a",
+          "version": "1.0.0",
+        },
+        Object {
+          "name": "pkg-b",
+          "version": "1.0.0",
+        },
+      ]
+    `);
+  });
+
+  it("should not bump version of an ignored package when its dependency gets updated", async () => {
+    const originalDate = Date;
+    // eslint-disable-next-line no-global-assign
+    Date = class Date {
+      toISOString() {
+        return "2021-12-13T00:07:30.879Z";
+      }
+    } as any;
+    try {
+      const cwd = await f.copy("simple-project");
+      await writeChangeset(
+        {
+          releases: [{ name: "pkg-b", type: "major" }],
+          summary: "a very useful summary"
+        },
+        cwd
+      );
+
+      await version(
+        cwd,
+        {
+          snapshot: true
+        },
+        {
+          ...modifiedDefaultConfig,
+          ignore: ["pkg-a"]
+        }
+      );
+
+      expect((await getPackages(cwd)).packages.map(x => x.packageJson))
+        .toMatchInlineSnapshot(`
+        Array [
+          Object {
+            "dependencies": Object {
+              "pkg-b": "0.0.0-20211213000730",
+            },
+            "name": "pkg-a",
+            "version": "1.0.0",
+          },
+          Object {
+            "name": "pkg-b",
+            "version": "0.0.0-20211213000730",
+          },
+        ]
+      `);
+    } finally {
+      // eslint-disable-next-line no-global-assign
+      Date = originalDate;
+    }
+  });
+
+  describe("useCalculatedVersionForSnapshots: true", () => {
+    it("should update packages using calculated version", async () => {
+      let cwd = f.copy("simple-project");
+      await writeChangesets([simpleChangeset2], cwd);
+      const spy = jest.spyOn(fs, "writeFile");
+      await version(
+        cwd,
+        {
+          snapshot: "experimental"
+        },
+        {
+          ...modifiedDefaultConfig,
+          commit: false,
+          ___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH: {
+            ...modifiedDefaultConfig.___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH,
+            useCalculatedVersionForSnapshots: true
+          }
+        }
+      );
+      expect(getPkgJSON("pkg-a", spy.mock.calls)).toEqual(
+        expect.objectContaining({
+          name: "pkg-a",
+          version: expect.stringContaining("1.1.0-experimental-")
+        })
+      );
+
+      expect(getPkgJSON("pkg-b", spy.mock.calls)).toEqual(
+        expect.objectContaining({
+          name: "pkg-b",
+          version: expect.stringContaining("1.0.1-experimental-")
+        })
+      );
+    });
+
+    it("should not bump version of a package with an explicit none release type", async () => {
+      const cwd = await f.copy("simple-project");
+      await writeChangeset(
+        {
+          releases: [{ name: "pkg-a", type: "none" }],
+          summary: "some internal stuff"
+        },
+        cwd
+      );
+
+      await version(
+        cwd,
+        {
+          snapshot: true
+        },
+        {
+          ...modifiedDefaultConfig,
+          ___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH: {
+            ...modifiedDefaultConfig.___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH,
+            useCalculatedVersionForSnapshots: true
+          }
+        }
+      );
+
+      expect((await getPackages(cwd)).packages.map(x => x.packageJson))
+        .toMatchInlineSnapshot(`
+        Array [
+          Object {
+            "dependencies": Object {
+              "pkg-b": "1.0.0",
+            },
+            "name": "pkg-a",
+            "version": "1.0.0",
+          },
+          Object {
+            "name": "pkg-b",
+            "version": "1.0.0",
+          },
+        ]
+      `);
+    });
+
+    it("should not bump version of an ignored package when its dependency gets updated", async () => {
+      const originalDate = Date;
+      // eslint-disable-next-line no-global-assign
+      Date = class Date {
+        toISOString() {
+          return "2021-12-13T00:07:30.879Z";
+        }
+      } as any;
+      try {
+        const cwd = await f.copy("simple-project");
+        await writeChangeset(
+          {
+            releases: [{ name: "pkg-b", type: "major" }],
+            summary: "a very useful summary"
+          },
+          cwd
+        );
+
+        await version(
+          cwd,
+          {
+            snapshot: true
+          },
+          {
+            ...modifiedDefaultConfig,
+            ignore: ["pkg-a"],
+            ___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH: {
+              ...modifiedDefaultConfig.___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH,
+              useCalculatedVersionForSnapshots: true
+            }
+          }
+        );
+
+        expect((await getPackages(cwd)).packages.map(x => x.packageJson))
+          .toMatchInlineSnapshot(`
+          Array [
+            Object {
+              "dependencies": Object {
+                "pkg-b": "2.0.0-20211213000730",
+              },
+              "name": "pkg-a",
+              "version": "1.0.0",
+            },
+            Object {
+              "name": "pkg-b",
+              "version": "2.0.0-20211213000730",
+            },
+          ]
+        `);
+      } finally {
+        // eslint-disable-next-line no-global-assign
+        Date = originalDate;
+      }
+    });
+  });
+});
+
+describe("updateInternalDependents: always", () => {
+  it("should bump a direct dependent when a dependency package gets bumped", async () => {
+    const cwd = await f.copy("simple-project-caret-dep");
+    const spy = jest.spyOn(fs, "writeFile");
+    await writeChangeset(simpleChangeset3, cwd);
+    await version(cwd, defaultOptions, {
+      ...modifiedDefaultConfig,
+      ___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH: {
+        ...defaultConfig.___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH,
+        updateInternalDependents: "always"
+      }
+    });
+
+    expect(getPkgJSON("pkg-a", spy.mock.calls)).toEqual(
+      expect.objectContaining({
+        name: "pkg-a",
+        version: "1.0.1",
+        dependencies: {
+          "pkg-b": "^1.0.1"
+        }
+      })
+    );
+    expect(getPkgJSON("pkg-b", spy.mock.calls)).toEqual(
+      expect.objectContaining({
+        name: "pkg-b",
+        version: "1.0.1"
+      })
+    );
+    expect(getChangelog("pkg-a", spy.mock.calls)).toMatchInlineSnapshot(`
+      "# pkg-a
+
+      ## 1.0.1
+
+      ### Patch Changes
+
+      - Updated dependencies [g1th4sh]
+        - pkg-b@1.0.1
+      "
+    `);
+    expect(getChangelog("pkg-b", spy.mock.calls)).toMatchInlineSnapshot(`
+      "# pkg-b
+
+      ## 1.0.1
+
+      ### Patch Changes
+
+      - g1th4sh: This is not a summary
+      "
+    `);
+  });
+});
+
+describe("pre", () => {
+  it("should work", async () => {
+    let cwd = f.copy("simple-project");
+    await pre(cwd, { command: "enter", tag: "next" });
+    await writeChangeset(
+      {
+        releases: [{ name: "pkg-b", type: "patch" }],
+        summary: "a very useful summary for the first change"
+      },
+      cwd
+    );
+    await version(cwd, defaultOptions, modifiedDefaultConfig);
+    let packages = (await getPackages(cwd))!;
+    expect(packages.packages.map(x => x.packageJson)).toEqual([
+      {
+        dependencies: {
+          "pkg-b": "1.0.1-next.0"
+        },
+        name: "pkg-a",
+        version: "1.0.1-next.0"
+      },
+      {
+        name: "pkg-b",
+        version: "1.0.1-next.0"
+      }
+    ]);
+    await writeChangeset(
+      {
+        releases: [{ name: "pkg-a", type: "patch" }],
+        summary: "a very useful summary"
+      },
+      cwd
+    );
+
+    await version(cwd, defaultOptions, modifiedDefaultConfig);
+    packages = (await getPackages(cwd))!;
+    expect(packages.packages.map(x => x.packageJson)).toEqual([
+      {
+        dependencies: {
+          "pkg-b": "1.0.1-next.0"
+        },
+        name: "pkg-a",
+        version: "1.0.1-next.1"
+      },
+      {
+        name: "pkg-b",
+        version: "1.0.1-next.0"
+      }
+    ]);
+    await writeChangeset(
+      {
+        releases: [{ name: "pkg-a", type: "patch" }],
+        summary: "a very useful summary for the second change"
+      },
+      cwd
+    );
+    await version(cwd, defaultOptions, modifiedDefaultConfig);
+    packages = (await getPackages(cwd))!;
+    expect(packages.packages.map(x => x.packageJson)).toEqual([
+      {
+        dependencies: {
+          "pkg-b": "1.0.1-next.0"
+        },
+        name: "pkg-a",
+        version: "1.0.1-next.2"
+      },
+      {
+        name: "pkg-b",
+        version: "1.0.1-next.0"
+      }
+    ]);
+    await writeChangeset(
+      {
+        releases: [{ name: "pkg-a", type: "minor" }],
+        summary: "a very useful summary for the third change"
+      },
+      cwd
+    );
+    await version(cwd, defaultOptions, modifiedDefaultConfig);
+    packages = (await getPackages(cwd))!;
+    expect(packages.packages.map(x => x.packageJson)).toMatchInlineSnapshot(
+      [
+        {
+          dependencies: {
+            "pkg-b": "1.0.1-next.0"
+          },
+          name: "pkg-a",
+          version: "1.1.0-next.3"
+        },
+        {
+          name: "pkg-b",
+          version: "1.0.1-next.0"
+        }
+      ],
+      `
+      Object {
+        "0": Object {
+          "dependencies": Object {
+            "pkg-b": "1.0.1-next.0",
+          },
+          "name": "pkg-a",
+          "version": "1.1.0-next.3",
+        },
+        "1": Object {
+          "name": "pkg-b",
+          "version": "1.0.1-next.0",
+        },
+      }
+    `
+    );
+    await pre(cwd, { command: "exit" });
+    await version(cwd, defaultOptions, modifiedDefaultConfig);
+    packages = (await getPackages(cwd))!;
+    expect(packages.packages.map(x => x.packageJson)).toEqual([
+      {
+        dependencies: {
+          "pkg-b": "1.0.1"
+        },
+        name: "pkg-a",
+        version: "1.1.0"
+      },
+      {
+        name: "pkg-b",
+        version: "1.0.1"
+      }
+    ]);
+    expect(
+      await fs.readFile(
+        path.join(packages.packages[0].dir, "CHANGELOG.md"),
+        "utf8"
+      )
+    ).toMatchInlineSnapshot(`
+      "# pkg-a
+
+      ## 1.1.0
+
+      ### Minor Changes
+
+      - g1th4sh: a very useful summary for the third change
+
+      ### Patch Changes
+
+      - g1th4sh: a very useful summary
+      - g1th4sh: a very useful summary for the second change
+      - Updated dependencies [g1th4sh]
+        - pkg-b@1.0.1
+
+      ## 1.1.0-next.3
+
+      ### Minor Changes
+
+      - g1th4sh: a very useful summary for the third change
+
+      ## 1.0.1-next.2
+
+      ### Patch Changes
+
+      - g1th4sh: a very useful summary for the second change
+
+      ## 1.0.1-next.1
+
+      ### Patch Changes
+
+      - g1th4sh: a very useful summary
+
+      ## 1.0.1-next.0
+
+      ### Patch Changes
+
+      - Updated dependencies [g1th4sh]
+        - pkg-b@1.0.1-next.0
+      "
+    `);
+    expect(
+      await fs.readFile(
+        path.join(packages.packages[1].dir, "CHANGELOG.md"),
+        "utf8"
+      )
+    ).toMatchInlineSnapshot(`
+      "# pkg-b
+
+      ## 1.0.1
+
+      ### Patch Changes
+
+      - g1th4sh: a very useful summary for the first change
+
+      ## 1.0.1-next.0
+
+      ### Patch Changes
+
+      - g1th4sh: a very useful summary for the first change
+      "
+    `);
+  });
+  it("should work with adding a package while in pre mode", async () => {
+    let cwd = f.copy("simple-project");
+    await pre(cwd, { command: "enter", tag: "next" });
+    await writeChangeset(
+      {
+        releases: [{ name: "pkg-b", type: "patch" }],
+        summary: "a very useful summary for the first change"
+      },
+      cwd
+    );
+
+    await version(cwd, defaultOptions, modifiedDefaultConfig);
+    let packages = (await getPackages(cwd))!;
+    expect(packages.packages.map(x => x.packageJson)).toEqual([
+      {
+        dependencies: {
+          "pkg-b": "1.0.1-next.0"
+        },
+        name: "pkg-a",
+        version: "1.0.1-next.0"
+      },
+      {
+        name: "pkg-b",
+        version: "1.0.1-next.0"
+      }
+    ]);
+    await fs.mkdir(path.join(cwd, "packages", "pkg-c"));
+    await fs.writeJson(path.join(cwd, "packages", "pkg-c", "package.json"), {
+      name: "pkg-c",
+      version: "0.0.0"
+    });
+    await writeChangeset(
+      {
+        releases: [
+          { name: "pkg-b", type: "major" },
+          { name: "pkg-c", type: "patch" }
+        ],
+        summary: "a very useful summary for the first change"
+      },
+      cwd
+    );
+    await version(cwd, defaultOptions, modifiedDefaultConfig);
+    packages = (await getPackages(cwd))!;
+
+    expect(packages.packages.map(x => x.packageJson)).toEqual([
+      {
+        dependencies: {
+          "pkg-b": "2.0.0-next.1"
+        },
+        name: "pkg-a",
+        version: "1.0.1-next.1"
+      },
+      {
+        name: "pkg-b",
+        version: "2.0.0-next.1"
+      },
+      {
+        name: "pkg-c",
+        version: "0.0.1-next.0"
+      }
+    ]);
+  });
+  it("should work for my weird case", async () => {
+    let cwd = f.copy("simple-project");
+    await writeChangeset(
+      {
+        releases: [{ name: "pkg-a", type: "minor" }],
+        summary: "a very useful summary for the first change"
+      },
+      cwd
+    );
+    await version(cwd, defaultOptions, modifiedDefaultConfig);
+    let packages = (await getPackages(cwd))!;
+
+    expect(packages.packages.map(x => x.packageJson)).toEqual([
+      {
+        dependencies: { "pkg-b": "1.0.0" },
+        name: "pkg-a",
+        version: "1.1.0"
+      },
+      {
+        name: "pkg-b",
+        version: "1.0.0"
+      }
+    ]);
+
+    await pre(cwd, { command: "enter", tag: "next" });
+    await writeChangeset(
+      {
+        releases: [{ name: "pkg-a", type: "patch" }],
+        summary: "a very useful summary for the first change"
+      },
+      cwd
+    );
+    await version(cwd, defaultOptions, modifiedDefaultConfig);
+    packages = (await getPackages(cwd))!;
+
+    expect(packages.packages.map(x => x.packageJson)).toEqual([
+      {
+        dependencies: { "pkg-b": "1.0.0" },
+        name: "pkg-a",
+        version: "1.1.1-next.0"
+      },
+      {
+        name: "pkg-b",
+        version: "1.0.0"
+      }
+    ]);
+  });
+  // https://github.com/changesets/changesets/pull/382#discussion_r434434182
+  it("should bump patch version for packages that had prereleases, but caret dependencies are still in range", async () => {
+    let cwd = f.copy("simple-project-caret-dep");
+    await pre(cwd, { command: "enter", tag: "next" });
+    await writeChangeset(
+      {
+        releases: [{ name: "pkg-b", type: "patch" }],
+        summary: "a very useful summary for the first change"
+      },
+      cwd
+    );
+    await version(cwd, defaultOptions, modifiedDefaultConfig);
+
+    let packages = (await getPackages(cwd))!;
+    expect(packages.packages.map(x => x.packageJson)).toEqual([
+      {
+        dependencies: {
+          "pkg-b": "^1.0.1-next.0"
+        },
+        name: "pkg-a",
+        version: "1.0.1-next.0"
+      },
+      {
+        name: "pkg-b",
+        version: "1.0.1-next.0"
+      }
+    ]);
+
+    await pre(cwd, { command: "exit" });
+    await version(cwd, defaultOptions, modifiedDefaultConfig);
+
+    packages = (await getPackages(cwd))!;
+    expect(packages.packages.map(x => x.packageJson)).toEqual([
+      {
+        dependencies: {
+          "pkg-b": "^1.0.1"
+        },
+        name: "pkg-a",
+        version: "1.0.1"
+      },
+      {
+        name: "pkg-b",
+        version: "1.0.1"
+      }
+    ]);
+  });
+
+  it("should use the highest bump type between all prereleases when versioning a package", async () => {
+    let cwd = f.copy("simple-project");
+    await writeChangeset(
+      {
+        releases: [{ name: "pkg-a", type: "major" }],
+        summary: "a very useful summary for the first change"
+      },
+      cwd
+    );
+
+    await pre(cwd, { command: "enter", tag: "next" });
+    await version(cwd, defaultOptions, modifiedDefaultConfig);
+    let packages = (await getPackages(cwd))!;
+
+    expect(packages.packages.map(x => x.packageJson)).toEqual([
+      {
+        dependencies: { "pkg-b": "1.0.0" },
+        name: "pkg-a",
+        version: "2.0.0-next.0"
+      },
+      {
+        name: "pkg-b",
+        version: "1.0.0"
+      }
+    ]);
+
+    await writeChangeset(
+      {
+        releases: [{ name: "pkg-a", type: "minor" }],
+        summary: "a very useful summary for the second change"
+      },
+      cwd
+    );
+    await version(cwd, defaultOptions, modifiedDefaultConfig);
+    packages = (await getPackages(cwd))!;
+
+    expect(packages.packages.map(x => x.packageJson)).toEqual([
+      {
+        dependencies: { "pkg-b": "1.0.0" },
+        name: "pkg-a",
+        version: "2.0.0-next.1"
+      },
+      {
+        name: "pkg-b",
+        version: "1.0.0"
+      }
+    ]);
+  });
+  it("should use the highest bump type between all prereleases when versioning a dependent package", async () => {
+    let cwd = f.copy("simple-project");
+    await pre(cwd, { command: "enter", tag: "next" });
+
+    await writeChangeset(
+      {
+        releases: [{ name: "pkg-a", type: "major" }],
+        summary: "a very useful summary for the first change"
+      },
+      cwd
+    );
+
+    await version(cwd, defaultOptions, modifiedDefaultConfig);
+    let packages = (await getPackages(cwd))!;
+
+    expect(packages.packages.map(x => x.packageJson)).toEqual([
+      {
+        dependencies: { "pkg-b": "1.0.0" },
+        name: "pkg-a",
+        version: "2.0.0-next.0"
+      },
+      {
+        name: "pkg-b",
+        version: "1.0.0"
+      }
+    ]);
+
+    await writeChangeset(
+      {
+        releases: [{ name: "pkg-b", type: "minor" }],
+        summary: "a very useful summary for the second change"
+      },
+      cwd
+    );
+    await version(cwd, defaultOptions, modifiedDefaultConfig);
+    packages = (await getPackages(cwd))!;
+
+    expect(packages.packages.map(x => x.packageJson)).toEqual([
+      {
+        name: "pkg-a",
+        version: "2.0.0-next.1",
+        dependencies: { "pkg-b": "1.1.0-next.0" }
+      },
+      {
+        name: "pkg-b",
+        version: "1.1.0-next.0"
+      }
+    ]);
+  });
+
+  it("should not bump packages through devDependencies", async () => {
+    let cwd = f.copy("simple-dev-dep");
+    await writeChangeset(
+      {
+        releases: [{ name: "pkg-b", type: "major" }],
+        summary: "a very useful summary for the first change"
+      },
+      cwd
+    );
+
+    await pre(cwd, { command: "enter", tag: "next" });
+    await version(cwd, defaultOptions, modifiedDefaultConfig);
+    let packages = (await getPackages(cwd))!;
+
+    expect(packages.packages.map(x => x.packageJson)).toEqual([
+      {
+        devDependencies: { "pkg-b": "2.0.0-next.0" },
+        name: "pkg-a",
+        version: "1.0.0"
+      },
+      {
+        name: "pkg-b",
+        version: "2.0.0-next.0"
+      }
+    ]);
+  });
+  it("should not bump ignored packages through dependencies", async () => {
+    let cwd = f.copy("simple-project");
+    await writeChangeset(
+      {
+        releases: [{ name: "pkg-a", type: "major" }],
+        summary: "a very useful summary for the first change"
+      },
+      cwd
+    );
+
+    await writeChangeset(
+      {
+        releases: [{ name: "pkg-b", type: "major" }],
+        summary: "a very useful summary for the first change"
+      },
+      cwd
+    );
+
+    await pre(cwd, { command: "enter", tag: "next" });
+    await version(cwd, defaultOptions, {
+      ...modifiedDefaultConfig,
+      ignore: ["pkg-a"]
+    });
+    let packages = (await getPackages(cwd))!;
+
+    expect(packages.packages.map(x => x.packageJson)).toEqual([
+      {
+        dependencies: { "pkg-b": "2.0.0-next.0" },
+        name: "pkg-a",
+        version: "1.0.0"
+      },
+      {
+        name: "pkg-b",
+        version: "2.0.0-next.0"
+      }
+    ]);
+  });
+  it("should bump dependent of prerelease package when bumping a `workspace:~` dependency", async () => {
+    const cwd = f.copy("workspace-alias-range-dep");
+    await pre(cwd, { command: "enter", tag: "alpha" });
+
+    await writeChangeset(
+      {
+        releases: [{ name: "pkg-c", type: "patch" }],
+        summary: "a very useful summary for the change"
+      },
+      cwd
+    );
+    await version(cwd, defaultOptions, modifiedDefaultConfig);
+
+    let packages = await getPackages(cwd);
+    expect(packages.packages.map(x => x.packageJson)).toEqual([
+      {
+        name: "pkg-a",
+        version: "1.0.1-alpha.0",
+        dependencies: {
+          "pkg-b": "workspace:^",
+          "pkg-c": "workspace:~"
+        }
+      },
+      {
+        name: "pkg-b",
+        version: "1.0.0"
+      },
+      {
+        name: "pkg-c",
+        version: "1.0.1-alpha.0"
+      }
+    ]);
+  });
+
+  it("should replace star range for dependency in dependant package when that dependency has its first prerelease in an already active pre mode", async () => {
+    const cwd = f.copy("simple-star-dep");
+
+    await pre(cwd, { command: "enter", tag: "alpha" });
+
+    await writeChangeset(
+      {
+        releases: [{ name: "pkg-a", type: "patch" }],
+        summary: "a very useful summary for the change"
+      },
+      cwd
+    );
+
+    await version(cwd, defaultOptions, modifiedDefaultConfig);
+
+    expect((await getPackages(cwd)).packages.map(x => x.packageJson))
+      .toMatchInlineSnapshot(`
+      Array [
+        Object {
+          "dependencies": Object {
+            "pkg-b": "*",
+          },
+          "name": "pkg-a",
+          "version": "1.0.1-alpha.0",
+        },
+        Object {
+          "name": "pkg-b",
+          "version": "1.0.0",
+        },
+      ]
+    `);
+
+    await writeChangeset(
+      {
+        releases: [{ name: "pkg-b", type: "patch" }],
+        summary: "a very useful summary for the change"
+      },
+      cwd
+    );
+
+    await version(cwd, defaultOptions, modifiedDefaultConfig);
+
+    expect((await getPackages(cwd)).packages.map(x => x.packageJson))
+      .toMatchInlineSnapshot(`
+      Array [
+        Object {
+          "dependencies": Object {
+            "pkg-b": "1.0.1-alpha.0",
+          },
+          "name": "pkg-a",
+          "version": "1.0.1-alpha.1",
+        },
+        Object {
+          "name": "pkg-b",
+          "version": "1.0.1-alpha.0",
+        },
+      ]
+    `);
+  });
+
+  it("bumping dependency in pre mode should result in dependant with star range on that dependency to be patch bumped and that range to be replaced with exact version", async () => {
+    const cwd = f.copy("simple-star-dep");
+
+    await pre(cwd, { command: "enter", tag: "alpha" });
+
+    await writeChangeset(
+      {
+        releases: [{ name: "pkg-b", type: "patch" }],
+        summary: "a very useful summary for the change"
+      },
+      cwd
+    );
+
+    await version(cwd, defaultOptions, modifiedDefaultConfig);
+
+    expect((await getPackages(cwd)).packages.map(x => x.packageJson))
+      .toMatchInlineSnapshot(`
+      Array [
+        Object {
+          "dependencies": Object {
+            "pkg-b": "1.0.1-alpha.0",
+          },
+          "name": "pkg-a",
+          "version": "1.0.1-alpha.0",
+        },
+        Object {
+          "name": "pkg-b",
+          "version": "1.0.1-alpha.0",
+        },
+      ]
+    `);
+  });
+
+  it("bumping dependency in pre mode should result in dependant with workspace:* range on that dependency to be patch bumped without changing the dependency range", async () => {
+    const cwd = f.copy("simple-workspace-wildcard-range-dep");
+
+    await pre(cwd, { command: "enter", tag: "alpha" });
+
+    await writeChangeset(
+      {
+        releases: [{ name: "pkg-b", type: "patch" }],
+        summary: "a very useful summary for the change"
+      },
+      cwd
+    );
+
+    await version(cwd, defaultOptions, modifiedDefaultConfig);
+
+    expect((await getPackages(cwd)).packages.map(x => x.packageJson))
+      .toMatchInlineSnapshot(`
+      Array [
+        Object {
+          "dependencies": Object {
+            "pkg-b": "workspace:*",
+          },
+          "name": "pkg-a",
+          "version": "1.0.1-alpha.0",
+        },
+        Object {
+          "name": "pkg-b",
+          "version": "1.0.1-alpha.0",
+        },
+      ]
+    `);
+  });
+
+  it("bumping dependency in pre mode should result in dependant with workspace:^ range on that dependency to be patch bumped without changing the dependency range", async () => {
+    const cwd = f.copy("workspace-alias-range-dep");
+
+    await pre(cwd, { command: "enter", tag: "alpha" });
+
+    await writeChangeset(
+      {
+        releases: [{ name: "pkg-b", type: "patch" }],
+        summary: "a very useful summary for the change"
+      },
+      cwd
+    );
+
+    await version(cwd, defaultOptions, modifiedDefaultConfig);
+
+    expect((await getPackages(cwd)).packages.map(x => x.packageJson))
+      .toMatchInlineSnapshot(`
+      Array [
+        Object {
+          "dependencies": Object {
+            "pkg-b": "workspace:^",
+            "pkg-c": "workspace:~",
+          },
+          "name": "pkg-a",
+          "version": "1.0.1-alpha.0",
+        },
+        Object {
+          "name": "pkg-b",
+          "version": "1.0.1-alpha.0",
+        },
+        Object {
+          "name": "pkg-c",
+          "version": "1.0.0",
+        },
+      ]
+    `);
+  });
+
+  it("bumping dependency in pre mode should result in dependant with workspace:~ range on that dependency to be patch bumped without changing the dependency range", async () => {
+    const cwd = f.copy("workspace-alias-range-dep");
+
+    await pre(cwd, { command: "enter", tag: "alpha" });
+
+    await writeChangeset(
+      {
+        releases: [{ name: "pkg-c", type: "patch" }],
+        summary: "a very useful summary for the change"
+      },
+      cwd
+    );
+
+    await version(cwd, defaultOptions, modifiedDefaultConfig);
+
+    expect((await getPackages(cwd)).packages.map(x => x.packageJson))
+      .toMatchInlineSnapshot(`
+      Array [
+        Object {
+          "dependencies": Object {
+            "pkg-b": "workspace:^",
+            "pkg-c": "workspace:~",
+          },
+          "name": "pkg-a",
+          "version": "1.0.1-alpha.0",
+        },
+        Object {
+          "name": "pkg-b",
+          "version": "1.0.0",
+        },
+        Object {
+          "name": "pkg-c",
+          "version": "1.0.1-alpha.0",
+        },
+      ]
+    `);
+  });
+
+  describe("linked", () => {
+    it("should work with linked", async () => {
+      let linkedConfig = {
+        ...modifiedDefaultConfig,
+        linked: [["pkg-a", "pkg-b"]]
+      };
+      let cwd = f.copy("simple-project");
+      await writeChangeset(
+        {
+          releases: [{ name: "pkg-a", type: "minor" }],
+          summary: "a very useful summary"
+        },
+        cwd
+      );
+      await version(cwd, defaultOptions, linkedConfig);
+      let packages = (await getPackages(cwd))!;
+
+      expect(packages.packages.map(x => x.packageJson)).toEqual([
+        {
+          dependencies: { "pkg-b": "1.0.0" },
+          name: "pkg-a",
+          version: "1.1.0"
+        },
+        {
+          name: "pkg-b",
+          version: "1.0.0"
+        }
+      ]);
+
+      await pre(cwd, { command: "enter", tag: "next" });
+      await writeChangeset(
+        {
+          releases: [{ name: "pkg-b", type: "patch" }],
+          summary: "a very useful summary"
+        },
+        cwd
+      );
+      await version(cwd, defaultOptions, linkedConfig);
+      packages = (await getPackages(cwd))!;
+
+      expect(packages.packages.map(x => x.packageJson)).toEqual([
+        {
+          dependencies: { "pkg-b": "1.1.1-next.0" },
+          name: "pkg-a",
+          version: "1.1.1-next.0"
+        },
+        {
+          name: "pkg-b",
+          version: "1.1.1-next.0"
+        }
+      ]);
+      await writeChangeset(
+        {
+          releases: [{ name: "pkg-a", type: "patch" }],
+          summary: "a very useful summary"
+        },
+        cwd
+      );
+      await version(cwd, defaultOptions, linkedConfig);
+      packages = (await getPackages(cwd))!;
+      expect(packages.packages.map(x => x.packageJson)).toEqual([
+        {
+          dependencies: { "pkg-b": "1.1.1-next.0" },
+          name: "pkg-a",
+          version: "1.1.1-next.1"
+        },
+        {
+          name: "pkg-b",
+          version: "1.1.1-next.0"
+        }
+      ]);
+      await writeChangeset(
+        {
+          releases: [{ name: "pkg-a", type: "patch" }],
+          summary: "a very useful summary"
+        },
+        cwd
+      );
+      await version(cwd, defaultOptions, linkedConfig);
+      packages = (await getPackages(cwd))!;
+      expect(packages.packages.map(x => x.packageJson)).toEqual([
+        {
+          dependencies: { "pkg-b": "1.1.1-next.0" },
+          name: "pkg-a",
+          version: "1.1.1-next.2"
+        },
+        {
+          name: "pkg-b",
+          version: "1.1.1-next.0"
+        }
+      ]);
+    });
+
+    it("should use the highest bump type between all prereleases for a linked package when versioning a dependent package", async () => {
+      let linkedConfig = {
+        ...modifiedDefaultConfig,
+        linked: [["pkg-a", "pkg-b"]]
+      };
+      let cwd = f.copy("linked-and-not-linked-packages");
+      await pre(cwd, { command: "enter", tag: "next" });
+      await writeChangeset(
+        {
+          releases: [{ name: "pkg-a", type: "minor" }],
+          summary: "a very useful summary"
+        },
+        cwd
+      );
+      await version(cwd, defaultOptions, linkedConfig);
+      let packages = (await getPackages(cwd))!;
+
+      expect(packages.packages.map(x => x.packageJson)).toEqual([
+        {
+          name: "pkg-a",
+          version: "1.1.0-next.0"
+        },
+        {
+          name: "pkg-b",
+          version: "1.0.0",
+          dependencies: { "pkg-c": "0.1.0" }
+        },
+        {
+          name: "pkg-c",
+          version: "0.1.0"
+        }
+      ]);
+
+      await writeChangeset(
+        {
+          releases: [{ name: "pkg-c", type: "patch" }],
+          summary: "a very useful summary"
+        },
+        cwd
+      );
+      await version(cwd, defaultOptions, linkedConfig);
+      packages = (await getPackages(cwd))!;
+
+      expect(packages.packages.map(x => x.packageJson)).toEqual([
+        {
+          name: "pkg-a",
+          version: "1.1.0-next.0"
+        },
+        {
+          name: "pkg-b",
+          version: "1.1.0-next.1",
+          dependencies: { "pkg-c": "0.1.1-next.0" }
+        },
+        {
+          name: "pkg-c",
+          version: "0.1.1-next.0"
+        }
+      ]);
+    });
+    it("should not bump a linked package if its linked devDep gets released", async () => {
+      let linkedConfig = {
+        ...modifiedDefaultConfig,
+        linked: [["pkg-a", "pkg-b"]]
+      };
+      let cwd = f.copy("linked-packages-with-linked-dev-dep");
+      await writeChangeset(
+        {
+          releases: [{ name: "pkg-b", type: "patch" }],
+          summary: "a very useful summary"
+        },
+        cwd
+      );
+      await version(cwd, defaultOptions, linkedConfig);
+      let packages = (await getPackages(cwd))!;
+
+      expect(packages.packages.map(x => x.packageJson)).toEqual([
+        {
+          name: "pkg-a",
+          version: "1.0.0",
+          devDependencies: { "pkg-b": "1.0.1" }
+        },
+        {
+          name: "pkg-b",
+          version: "1.0.1"
+        }
+      ]);
+    });
+  });
+});
diff --git a/node_modules/@changesets/cli/src/commit/commit.test.ts b/node_modules/@changesets/cli/src/commit/commit.test.ts
new file mode 100644
index 0000000..2564dcd
--- /dev/null
+++ b/node_modules/@changesets/cli/src/commit/commit.test.ts
@@ -0,0 +1,214 @@
+import outdent from "outdent";
+import defaultCommitFunctions from ".";
+import { NewChangeset, ReleasePlan } from "@changesets/types";
+
+const simpleChangeset: NewChangeset = {
+  summary: "This is a summary",
+  releases: [{ name: "package-a", type: "minor" }],
+  id: "abc123xy"
+};
+
+const simpleChangeset2: NewChangeset = {
+  summary: "This is another summary",
+  releases: [
+    { name: "package-a", type: "patch" },
+    { name: "package-b", type: "minor" }
+  ],
+  id: "abc123fh"
+};
+
+let simpleReleasePlan: ReleasePlan = {
+  changesets: [simpleChangeset],
+  releases: [
+    {
+      name: "package-a",
+      type: "minor",
+      oldVersion: "1.0.0",
+      newVersion: "1.1.0",
+      changesets: [simpleChangeset.id]
+    }
+  ],
+  preState: undefined
+};
+
+let secondReleasePlan: ReleasePlan = {
+  changesets: [simpleChangeset, simpleChangeset2],
+  releases: [
+    {
+      name: "package-a",
+      type: "minor",
+      oldVersion: "1.0.0",
+      newVersion: "1.1.0",
+      changesets: [simpleChangeset.id]
+    },
+    {
+      name: "package-b",
+      type: "minor",
+      oldVersion: "1.0.0",
+      newVersion: "1.1.0",
+      changesets: [simpleChangeset2.id]
+    }
+  ],
+  preState: undefined
+};
+
+describe("defaultCommitFunctions", () => {
+  const { getAddMessage, getVersionMessage } = defaultCommitFunctions;
+
+  it("should handle a simple changeset", async () => {
+    const commitStr = await getAddMessage(
+      {
+        summary: "test changeset summary commit",
+        releases: [
+          {
+            name: "package-a",
+            type: "minor"
+          }
+        ]
+      },
+      { skipCI: "version" }
+    );
+    expect(commitStr).toEqual(`docs(changeset): test changeset summary commit`);
+  });
+
+  it("should handle a simple changeset - skipCI", async () => {
+    const commitStr = await getAddMessage(
+      {
+        summary: "test changeset summary commit",
+        releases: [
+          {
+            name: "package-a",
+            type: "minor"
+          }
+        ]
+      },
+      { skipCI: "add" }
+    );
+    expect(commitStr).toEqual(outdent`
+        docs(changeset): test changeset summary commit
+
+        [skip ci]
+
+      `);
+  });
+
+  it("should handle a single simple releaseObject with one released package - skipCI", async () => {
+    const commitStr = await getVersionMessage(simpleReleasePlan, {
+      skipCI: "version"
+    });
+    expect(commitStr).toEqual(outdent`
+      RELEASING: Releasing 1 package(s)
+
+      Releases:
+        package-a@1.1.0
+
+      [skip ci]
+
+      `);
+  });
+
+  it("should handle a single simple releaseObject with one released package", async () => {
+    const commitStr = await getVersionMessage(simpleReleasePlan, {
+      skipCI: false
+    });
+    expect(commitStr).toEqual(outdent`
+      RELEASING: Releasing 1 package(s)
+
+      Releases:
+        package-a@1.1.0
+
+      `);
+  });
+
+  it("should handle a multiple releases from one changeset", async () => {
+    let releasePlan: ReleasePlan = {
+      changesets: [simpleChangeset, simpleChangeset2],
+      releases: [
+        {
+          name: "package-a",
+          type: "patch",
+          oldVersion: "1.0.0",
+          newVersion: "1.0.1",
+          changesets: [simpleChangeset.id]
+        },
+        {
+          name: "package-b",
+          type: "minor",
+          oldVersion: "1.0.0",
+          newVersion: "1.1.0",
+          changesets: [simpleChangeset2.id]
+        }
+      ],
+      preState: undefined
+    };
+    const commitStr = await getVersionMessage(releasePlan, {
+      skipCI: "version"
+    });
+    expect(commitStr).toEqual(outdent`
+      RELEASING: Releasing 2 package(s)
+
+      Releases:
+        package-a@1.0.1
+        package-b@1.1.0
+
+      [skip ci]
+
+    `);
+  });
+
+  it("should handle a merging releases from multiple changesets", async () => {
+    const commitStr = await getVersionMessage(secondReleasePlan, {
+      skipCI: "version"
+    });
+
+    expect(commitStr).toEqual(outdent`
+      RELEASING: Releasing 2 package(s)
+
+      Releases:
+        package-a@1.1.0
+        package-b@1.1.0
+
+      [skip ci]
+
+    `);
+  });
+
+  it("should not mention unreleased devDependents in release commit message", async () => {
+    const commitStr = await getVersionMessage(
+      {
+        changesets: [
+          {
+            id: "quick-lions-devour",
+            summary: "Hey, let's have fun with testing!",
+            releases: [
+              { name: "pkg-a", type: "none" },
+              { name: "pkg-b", type: "minor" }
+            ]
+          }
+        ],
+        releases: [
+          {
+            name: "pkg-a",
+            type: "none",
+            oldVersion: "1.0.0",
+            newVersion: "1.0.0",
+            changesets: ["quick-lions-devour"]
+          },
+          {
+            name: "pkg-b",
+            type: "minor",
+            oldVersion: "1.0.0",
+            newVersion: "1.1.0",
+            changesets: ["quick-lions-devour"]
+          }
+        ],
+        preState: undefined
+      },
+      { skipCI: "version" }
+    );
+
+    expect(commitStr).toMatch("RELEASING: Releasing 1 package(s)");
+    expect(commitStr).toMatch("pkg-b@1.1.0");
+    expect(commitStr).not.toMatch("pkg-a");
+  });
+});
diff --git a/node_modules/@changesets/cli/src/commit/getCommitFunctions.ts b/node_modules/@changesets/cli/src/commit/getCommitFunctions.ts
new file mode 100644
index 0000000..50c66c5
--- /dev/null
+++ b/node_modules/@changesets/cli/src/commit/getCommitFunctions.ts
@@ -0,0 +1,30 @@
+import { CommitFunctions } from "@changesets/types";
+import path from "path";
+import resolveFrom from "resolve-from";
+
+export function getCommitFunctions(
+  commit: false | readonly [string, any],
+  cwd: string
+): [CommitFunctions, any] {
+  let commitFunctions: CommitFunctions = {};
+  if (!commit) {
+    return [commitFunctions, null];
+  }
+  let commitOpts: any = commit[1];
+  let changesetPath = path.join(cwd, ".changeset");
+  let commitPath = resolveFrom(changesetPath, commit[0]);
+
+  let possibleCommitFunc = require(commitPath);
+  if (possibleCommitFunc.default) {
+    possibleCommitFunc = possibleCommitFunc.default;
+  }
+  if (
+    typeof possibleCommitFunc.getAddMessage === "function" ||
+    typeof possibleCommitFunc.getVersionMessage === "function"
+  ) {
+    commitFunctions = possibleCommitFunc;
+  } else {
+    throw new Error("Could not resolve commit generation functions");
+  }
+  return [commitFunctions, commitOpts];
+}
diff --git a/node_modules/@changesets/cli/src/commit/index.ts b/node_modules/@changesets/cli/src/commit/index.ts
new file mode 100644
index 0000000..ce35c74
--- /dev/null
+++ b/node_modules/@changesets/cli/src/commit/index.ts
@@ -0,0 +1,44 @@
+import { Changeset, CommitFunctions, ReleasePlan } from "@changesets/types";
+import outdent from "outdent";
+
+type SkipCI = boolean | "add" | "version";
+
+const getAddMessage: CommitFunctions["getAddMessage"] = async (
+  changeset: Changeset,
+  options: { skipCI?: SkipCI } | null
+) => {
+  const skipCI = options?.skipCI === "add" || options?.skipCI === true;
+  return outdent`docs(changeset): ${changeset.summary}${
+    skipCI ? `\n\n[skip ci]\n` : ""
+  }`;
+};
+
+const getVersionMessage: CommitFunctions["getVersionMessage"] = async (
+  releasePlan: ReleasePlan,
+  options: { skipCI?: SkipCI } | null
+) => {
+  const skipCI = options?.skipCI === "version" || options?.skipCI === true;
+  const publishableReleases = releasePlan.releases.filter(
+    release => release.type !== "none"
+  );
+  const numPackagesReleased = publishableReleases.length;
+
+  const releasesLines = publishableReleases
+    .map(release => `  ${release.name}@${release.newVersion}`)
+    .join("\n");
+
+  return outdent`
+    RELEASING: Releasing ${numPackagesReleased} package(s)
+
+    Releases:
+    ${releasesLines}
+    ${skipCI ? `\n[skip ci]\n` : ""}
+`;
+};
+
+const defaultCommitFunctions: Required<CommitFunctions> = {
+  getAddMessage,
+  getVersionMessage
+};
+
+export default defaultCommitFunctions;
diff --git a/node_modules/@changesets/cli/src/index.ts b/node_modules/@changesets/cli/src/index.ts
new file mode 100644
index 0000000..f11778b
--- /dev/null
+++ b/node_modules/@changesets/cli/src/index.ts
@@ -0,0 +1,99 @@
+import meow from "meow";
+import { ExitError, InternalError } from "@changesets/errors";
+import { error } from "@changesets/logger";
+import { format } from "util";
+import { run } from "./run";
+
+const { input, flags } = meow(
+  `
+  Usage
+    $ changeset [command]
+  Commands
+    init
+    add [--empty] [--open]
+    version [--ignore] [--snapshot <?name>]
+    publish [--tag <name>] [--otp <code>] [--no-git-tag]
+    status [--since <branch>] [--verbose] [--output JSON_FILE.json]
+    pre <enter|exit> <tag>
+    tag
+    `,
+  {
+    flags: {
+      sinceMaster: {
+        type: "boolean"
+      },
+      verbose: {
+        type: "boolean",
+        alias: "v"
+      },
+      output: {
+        type: "string",
+        alias: "o"
+      },
+      otp: {
+        type: "string"
+      },
+      empty: {
+        type: "boolean"
+      },
+      since: {
+        type: "string"
+      },
+      ignore: {
+        type: "string",
+        isMultiple: true
+      },
+      tag: {
+        type: "string"
+      },
+      open: {
+        type: "boolean"
+      },
+      gitTag: {
+        type: "boolean",
+        default: true
+      }
+      // mixed type like this is not supported by `meow`
+      // if it gets passed explicitly then it's still available on the flags with an inferred type though
+      // snapshot: { type: "boolean" | "string" },
+    }
+  }
+);
+
+const cwd = process.cwd();
+
+run(input, flags, cwd).catch(err => {
+  if (err instanceof InternalError) {
+    error(
+      "The following error is an internal unexpected error, these should never happen."
+    );
+    error("Please open an issue with the following link");
+    error(
+      `https://github.com/changesets/changesets/issues/new?title=${encodeURIComponent(
+        `Unexpected error during ${input[0] || "add"} command`
+      )}&body=${encodeURIComponent(`## Error
+
+\`\`\`
+${format("", err).replace(process.cwd(), "<cwd>")}
+\`\`\`
+
+## Versions
+
+- @changesets/cli@${
+        // eslint-disable-next-line import/no-extraneous-dependencies
+        require("@changesets/cli/package.json").version
+      }
+- node@${process.version}
+
+## Extra details
+
+<!-- Add any extra details of what you were doing, ideas you have about what might have caused the error and reproduction steps if possible. If you have a repository we can look at that would be great. 😁 -->
+`)}`
+    );
+  }
+  if (err instanceof ExitError) {
+    return process.exit(err.code);
+  }
+  error(err);
+  process.exit(1);
+});
diff --git a/node_modules/@changesets/cli/src/run.test.ts b/node_modules/@changesets/cli/src/run.test.ts
new file mode 100644
index 0000000..4a6b6c3
--- /dev/null
+++ b/node_modules/@changesets/cli/src/run.test.ts
@@ -0,0 +1,60 @@
+import fixtures from "fixturez";
+import { error } from "@changesets/logger";
+
+import { run } from "./run";
+
+const f = fixtures(__dirname);
+jest.mock("@changesets/logger");
+jest.mock("./commands/version");
+
+describe("cli", () => {
+  describe("version", () => {
+    let cwd: string;
+    beforeEach(async () => {
+      cwd = await f.copy("simple-project");
+    });
+
+    it("should validate package name passed in from --ignore flag", async () => {
+      try {
+        await run(["version"], { ignore: "pkg-c" }, cwd);
+      } catch (e) {
+        // ignore errors. We just want to validate the error message
+      }
+
+      const loggerErrorCalls = (error as any).mock.calls;
+      expect(loggerErrorCalls.length).toEqual(1);
+      expect(loggerErrorCalls[0][0]).toEqual(
+        `The package "pkg-c" is passed to the \`--ignore\` option but it is not found in the project. You may have misspelled the package name.`
+      );
+    });
+
+    it("should throw if dependents of ignored packages are not explicitly listed in the ignore array", async () => {
+      try {
+        await run(["version"], { ignore: ["pkg-b"] }, cwd);
+      } catch (e) {
+        // ignore the error. We just want to validate the error message
+      }
+
+      const loggerErrorCalls = (error as any).mock.calls;
+      expect(loggerErrorCalls.length).toEqual(1);
+      expect(loggerErrorCalls[0][0]).toEqual(
+        `The package "pkg-a" depends on the ignored package "pkg-b", but "pkg-a" is not being ignored. Please pass "pkg-a" to the \`--ignore\` flag.`
+      );
+    });
+
+    it("should throw if `--ignore` flag is used while ignore array is also defined in the config file ", async () => {
+      cwd = await f.copy("simple-project-with-ignore-config");
+      try {
+        await run(["version"], { ignore: "pkg-b" }, cwd);
+      } catch (e) {
+        // ignore errors. We just want to validate the error message
+      }
+
+      const loggerErrorCalls = (error as any).mock.calls;
+      expect(loggerErrorCalls.length).toEqual(1);
+      expect(loggerErrorCalls[0][0]).toEqual(
+        `It looks like you are trying to use the \`--ignore\` option while ignore is defined in the config file. This is currently not allowed, you can only use one of them at a time.`
+      );
+    });
+  });
+});
diff --git a/node_modules/@changesets/cli/src/run.ts b/node_modules/@changesets/cli/src/run.ts
new file mode 100644
index 0000000..3514528
--- /dev/null
+++ b/node_modules/@changesets/cli/src/run.ts
@@ -0,0 +1,221 @@
+import { Config } from "@changesets/types";
+import fs from "fs-extra";
+import path from "path";
+import { getPackages } from "@manypkg/get-packages";
+import { getDependentsGraph } from "@changesets/get-dependents-graph";
+import { error } from "@changesets/logger";
+import { read } from "@changesets/config";
+import { ExitError } from "@changesets/errors";
+
+import init from "./commands/init";
+import add from "./commands/add";
+import version from "./commands/version";
+import publish from "./commands/publish";
+import status from "./commands/status";
+import pre from "./commands/pre";
+import tagCommand from "./commands/tag";
+import { CliOptions } from "./types";
+
+export async function run(
+  input: string[],
+  flags: { [name: string]: any },
+  cwd: string
+) {
+  if (input[0] === "init") {
+    await init(cwd);
+    return;
+  }
+
+  if (!fs.existsSync(path.resolve(cwd, ".changeset"))) {
+    error("There is no .changeset folder. ");
+    error(
+      "If this is the first time `changesets` have been used in this project, run `yarn changeset init` to get set up."
+    );
+    error(
+      "If you expected there to be changesets, you should check git history for when the folder was removed to ensure you do not lose any configuration."
+    );
+    throw new ExitError(1);
+  }
+
+  const packages = await getPackages(cwd);
+
+  let config: Config;
+  try {
+    config = await read(cwd, packages);
+  } catch (e) {
+    let oldConfigExists = await fs.pathExists(
+      path.resolve(cwd, ".changeset/config.js")
+    );
+    if (oldConfigExists) {
+      error(
+        "It looks like you're using the version 1 `.changeset/config.js` file"
+      );
+      error("You'll need to convert it to a `.changeset/config.json` file");
+      error(
+        "The format of the config object has significantly changed in v2 as well"
+      );
+      error(
+        " - we thoroughly recommend looking at the changelog for this package for what has changed"
+      );
+      throw new ExitError(1);
+    } else {
+      throw e;
+    }
+  }
+
+  if (input.length < 1) {
+    const { empty, open }: CliOptions = flags;
+    // @ts-ignore if this is undefined, we have already exited
+    await add(cwd, { empty, open }, config);
+  } else if (input[0] !== "pre" && input.length > 1) {
+    error(
+      "Too many arguments passed to changesets - we only accept the command name as an argument"
+    );
+  } else {
+    const {
+      sinceMaster,
+      since,
+      verbose,
+      output,
+      otp,
+      empty,
+      ignore,
+      snapshot,
+      tag,
+      open,
+      gitTag
+    }: CliOptions = flags;
+    const deadFlags = ["updateChangelog", "isPublic", "skipCI", "commit"];
+
+    deadFlags.forEach(flag => {
+      if (flags[flag]) {
+        error(
+          `the flag ${flag} has been removed from changesets for version 2`
+        );
+        error(`Please encode the desired value into your config`);
+        error(`See our changelog for more details`);
+        throw new ExitError(1);
+      }
+    });
+
+    // Command line options need to be undefined, otherwise their
+    // default value overrides the user's provided config in their
+    // config file. For this reason, we only assign them to this
+    // object as and when they exist.
+
+    switch (input[0]) {
+      case "add": {
+        await add(cwd, { empty, open }, config);
+        return;
+      }
+      case "version": {
+        let ignoreArrayFromCmd: undefined | string[];
+        if (typeof ignore === "string") {
+          ignoreArrayFromCmd = [ignore];
+        } else {
+          // undefined or an array
+          ignoreArrayFromCmd = ignore;
+        }
+
+        // Validate that items in ignoreArrayFromCmd are valid project names
+        let pkgNames = new Set(
+          packages.packages.map(({ packageJson }) => packageJson.name)
+        );
+
+        const messages = [];
+        for (const pkgName of ignoreArrayFromCmd || []) {
+          if (!pkgNames.has(pkgName)) {
+            messages.push(
+              `The package "${pkgName}" is passed to the \`--ignore\` option but it is not found in the project. You may have misspelled the package name.`
+            );
+          }
+        }
+
+        if (config.ignore.length > 0 && ignoreArrayFromCmd) {
+          messages.push(
+            `It looks like you are trying to use the \`--ignore\` option while ignore is defined in the config file. This is currently not allowed, you can only use one of them at a time.`
+          );
+        } else if (ignoreArrayFromCmd) {
+          // use the ignore flags from cli
+          config.ignore = ignoreArrayFromCmd;
+        }
+
+        // Validate that all dependents of ignored packages are listed in the ignore list
+        const dependentsGraph = getDependentsGraph(packages, {
+          bumpVersionsWithWorkspaceProtocolOnly:
+            config.bumpVersionsWithWorkspaceProtocolOnly
+        });
+        for (const ignoredPackage of config.ignore) {
+          const dependents = dependentsGraph.get(ignoredPackage) || [];
+          for (const dependent of dependents) {
+            if (!config.ignore.includes(dependent)) {
+              messages.push(
+                `The package "${dependent}" depends on the ignored package "${ignoredPackage}", but "${dependent}" is not being ignored. Please pass "${dependent}" to the \`--ignore\` flag.`
+              );
+            }
+          }
+        }
+
+        if (messages.length > 0) {
+          error(messages.join("\n"));
+
+          throw new ExitError(1);
+        }
+
+        await version(cwd, { snapshot }, config);
+        return;
+      }
+      case "publish": {
+        await publish(cwd, { otp, tag, gitTag }, config);
+        return;
+      }
+      case "status": {
+        await status(cwd, { sinceMaster, since, verbose, output }, config);
+        return;
+      }
+      case "tag": {
+        await tagCommand(cwd);
+        return;
+      }
+      case "pre": {
+        let command = input[1];
+        if (command !== "enter" && command !== "exit") {
+          error(
+            "`enter`, `exit` or `snapshot` must be passed after prerelease"
+          );
+          throw new ExitError(1);
+        }
+        let tag = input[2];
+        if (command === "enter" && typeof tag !== "string") {
+          error(`A tag must be passed when using prerelese enter`);
+          throw new ExitError(1);
+        }
+        // @ts-ignore
+        await pre(cwd, { command, tag });
+        return;
+      }
+      case "bump": {
+        error(
+          'In version 2 of changesets, "bump" has been renamed to "version" - see our changelog for an explanation'
+        );
+        error(
+          "To fix this, use `changeset version` instead, and update any scripts that use changesets"
+        );
+        throw new ExitError(1);
+      }
+      case "release": {
+        error(
+          'In version 2 of changesets, "release" has been renamed to "publish" - see our changelog for an explanation'
+        );
+        error(
+          "To fix this, use `changeset publish` instead, and update any scripts that use changesets"
+        );
+        throw new ExitError(1);
+      }
+      default: {
+        error(`Invalid command ${input[0]} was provided`);
+        throw new ExitError(1);
+      }
+    }
+  }
+}
diff --git a/node_modules/@changesets/cli/src/types.ts b/node_modules/@changesets/cli/src/types.ts
new file mode 100644
index 0000000..73ae083
--- /dev/null
+++ b/node_modules/@changesets/cli/src/types.ts
@@ -0,0 +1,17 @@
+export type CliOptions = {
+  sinceMaster?: boolean;
+  verbose?: boolean;
+  output?: string;
+  otp?: string;
+  empty?: boolean;
+  since?: string;
+  ignore?: string | string[];
+  snapshot?: string | boolean;
+  tag?: string;
+  gitTag?: boolean;
+  open?: boolean;
+};
+
+export type CommandOptions = CliOptions & {
+  cwd: string;
+};
diff --git a/node_modules/@changesets/cli/src/utils/cli-utilities.ts b/node_modules/@changesets/cli/src/utils/cli-utilities.ts
new file mode 100644
index 0000000..603bc61
--- /dev/null
+++ b/node_modules/@changesets/cli/src/utils/cli-utilities.ts
@@ -0,0 +1,152 @@
+// @ts-ignore it's not worth writing a TS declaration file in this repo for a tiny module we use once like this
+import termSize from "term-size";
+import { error, prefix, success } from "@changesets/logger";
+import { prompt } from "enquirer";
+import { edit } from "external-editor";
+import { symbols } from "ansi-colors";
+
+// those types are not exported from `enquirer` so we extract them here
+// so we can make type assertions using them because `enquirer` types do no support `prefix` right now
+type PromptOptions = Extract<Parameters<typeof prompt>[0], { type: string }>;
+type ArrayPromptOptions = Extract<
+  PromptOptions,
+  {
+    type:
+      | "autocomplete"
+      | "editable"
+      | "form"
+      | "multiselect"
+      | "select"
+      | "survey"
+      | "list"
+      | "scale";
+  }
+>;
+type BooleanPromptOptions = Extract<PromptOptions, { type: "confirm" }>;
+type StringPromptOptions = Extract<
+  PromptOptions,
+  { type: "input" | "invisible" | "list" | "password" | "text" }
+>;
+
+/* Notes on using inquirer:
+ * Each question needs a key, as inquirer is assembling an object behind-the-scenes.
+ * At each call, the entire responses object is returned, so we need a unique
+ * identifier for the name every time. This is why we are using serial IDs
+ */
+const serialId: () => number = (function() {
+  let id = 0;
+  return () => id++;
+})();
+
+const limit = Math.max(termSize().rows - 5, 10);
+
+let cancelFlow = () => {
+  success("Cancelled... 👋 ");
+  process.exit();
+};
+
+async function askCheckboxPlus(
+  message: string,
+  choices: Array<any>,
+  format?: (arg: any) => any
+): Promise<Array<string>> {
+  const name = `CheckboxPlus-${serialId()}`;
+
+  return prompt({
+    type: "autocomplete",
+    name,
+    message,
+    prefix,
+    multiple: true,
+    choices,
+    format,
+    limit,
+    onCancel: cancelFlow,
+    symbols: {
+      indicator: symbols.radioOff,
+      checked: symbols.radioOn
+    },
+    indicator(state: any, choice: any) {
+      return choice.enabled ? state.symbols.checked : state.symbols.indicator;
+    }
+  } as ArrayPromptOptions)
+    .then((responses: any) => responses[name])
+    .catch((err: unknown) => {
+      error(err);
+    });
+}
+
+async function askQuestion(message: string): Promise<string> {
+  const name = `Question-${serialId()}`;
+
+  return prompt([
+    {
+      type: "input",
+      message,
+      name,
+      prefix,
+      onCancel: cancelFlow
+    } as StringPromptOptions
+  ])
+    .then((responses: any) => responses[name])
+    .catch((err: unknown) => {
+      error(err);
+    });
+}
+
+function askQuestionWithEditor(message: string): string {
+  const response = edit(message, { postfix: ".md" });
+  return response
+    .replace(/^#.*\n?/gm, "")
+    .replace(/\n+$/g, "")
+    .trim();
+}
+
+async function askConfirm(message: string): Promise<boolean> {
+  const name = `Confirm-${serialId()}`;
+
+  return prompt([
+    {
+      message,
+      name,
+      prefix,
+      type: "confirm",
+      initial: true,
+      onCancel: cancelFlow
+    } as BooleanPromptOptions
+  ])
+    .then((responses: any) => responses[name])
+    .catch((err: unknown) => {
+      error(err);
+    });
+}
+
+async function askList<Choice extends string>(
+  message: string,
+  choices: Choice[]
+): Promise<Choice> {
+  const name = `List-${serialId()}`;
+
+  return prompt([
+    {
+      choices,
+      message,
+      name,
+      prefix,
+      type: "select",
+      onCancel: cancelFlow
+    } as ArrayPromptOptions
+  ])
+    .then((responses: any) => responses[name])
+    .catch((err: unknown) => {
+      error(err);
+    });
+}
+
+export {
+  askCheckboxPlus,
+  askQuestion,
+  askQuestionWithEditor,
+  askConfirm,
+  askList
+};
diff --git a/node_modules/@changesets/cli/src/utils/getLastJsonObjectFromString.test.ts b/node_modules/@changesets/cli/src/utils/getLastJsonObjectFromString.test.ts
new file mode 100644
index 0000000..a0923ba
--- /dev/null
+++ b/node_modules/@changesets/cli/src/utils/getLastJsonObjectFromString.test.ts
@@ -0,0 +1,70 @@
+import { getLastJsonObjectFromString } from "./getLastJsonObjectFromString";
+
+describe("getLastJsonObjectFromString", () => {
+  it("should handle stringified object", () => {
+    expect(
+      getLastJsonObjectFromString(JSON.stringify({ test: "foo" }))
+    ).toEqual({ test: "foo" });
+  });
+
+  it("should handle stringified deep object", () => {
+    expect(
+      getLastJsonObjectFromString(
+        JSON.stringify({
+          test: "foo",
+          bar: { baz: { qwe: "rty" }, arr: [1, 2, 3, 4] }
+        })
+      )
+    ).toEqual({
+      test: "foo",
+      bar: { baz: { qwe: "rty" }, arr: [1, 2, 3, 4] }
+    });
+  });
+
+  it("should handle leading whitespace", () => {
+    expect(
+      getLastJsonObjectFromString(
+        `   \n\n  ${JSON.stringify({ test: "foo", baz: { qwe: "rty" } })}`
+      )
+    ).toEqual({ test: "foo", baz: { qwe: "rty" } });
+  });
+
+  it("should handle trailing whitespace", () => {
+    expect(
+      getLastJsonObjectFromString(
+        `${JSON.stringify({ test: "foo", baz: { qwe: "rty" } })}   \n\n  `
+      )
+    ).toEqual({ test: "foo", baz: { qwe: "rty" } });
+  });
+
+  it("should handle trailing text", () => {
+    expect(
+      getLastJsonObjectFromString(
+        `${JSON.stringify({ test: "foo", baz: { qwe: "rty" } })}   \n\n  test`
+      )
+    ).toEqual({ test: "foo", baz: { qwe: "rty" } });
+  });
+
+  it("should handle string with multiple objects", () => {
+    expect(
+      getLastJsonObjectFromString(
+        `${JSON.stringify({
+          test: "foo",
+          baz: { qwe: "rty" }
+        })}   \n\n  ${JSON.stringify({ much: "awesome" })}`
+      )
+    ).toEqual({ much: "awesome" });
+  });
+
+  it("should return `null` for an empty string", () => {
+    expect(getLastJsonObjectFromString("")).toEqual(null);
+  });
+
+  it("should return `null` for a string with a broken object", () => {
+    expect(getLastJsonObjectFromString(`{"bar:"`)).toEqual(null);
+  });
+
+  it("should return `null` for a string without an object", () => {
+    expect(getLastJsonObjectFromString(`qwerty`)).toEqual(null);
+  });
+});
diff --git a/node_modules/@changesets/cli/src/utils/getLastJsonObjectFromString.ts b/node_modules/@changesets/cli/src/utils/getLastJsonObjectFromString.ts
new file mode 100644
index 0000000..5328537
--- /dev/null
+++ b/node_modules/@changesets/cli/src/utils/getLastJsonObjectFromString.ts
@@ -0,0 +1,15 @@
+export const getLastJsonObjectFromString = (str: string) => {
+  str = str.replace(/[^}]*$/, "");
+
+  while (str) {
+    str = str.replace(/[^{]*/, "");
+
+    try {
+      return JSON.parse(str);
+    } catch (err) {
+      // move past the potentially leading `{` so the regexp in the loop can try to match for the next `{`
+      str = str.slice(1);
+    }
+  }
+  return null;
+};
diff --git a/node_modules/@changesets/cli/src/utils/types.ts b/node_modules/@changesets/cli/src/utils/types.ts
new file mode 100644
index 0000000..4be5347
--- /dev/null
+++ b/node_modules/@changesets/cli/src/utils/types.ts
@@ -0,0 +1,4 @@
+export type TwoFactorState = {
+  token: string | null;
+  isRequired: Promise<boolean>;
+};
diff --git a/node_modules/@changesets/cli/src/utils/v1-legacy/README.md b/node_modules/@changesets/cli/src/utils/v1-legacy/README.md
new file mode 100644
index 0000000..0dd27aa
--- /dev/null
+++ b/node_modules/@changesets/cli/src/utils/v1-legacy/README.md
@@ -0,0 +1,4 @@
+# Quick Note
+
+These exist in the changeset codebase specifically to support still processing v1 changesets
+and should be removed once this support is finished.
diff --git a/node_modules/@changesets/cli/src/utils/v1-legacy/removeFolders.ts b/node_modules/@changesets/cli/src/utils/v1-legacy/removeFolders.ts
new file mode 100644
index 0000000..98e8495
--- /dev/null
+++ b/node_modules/@changesets/cli/src/utils/v1-legacy/removeFolders.ts
@@ -0,0 +1,26 @@
+import path from "path";
+import fs from "fs-extra";
+
+// This helper is designed to operate on the .changeset
+// folder, and tidy up the subfolders
+// THIS SHOULD BE REMOVED WHEN SUPPORT FOR CHANGESETS FROM V1 IS DROPPED
+
+const removeEmptyFolders = async (folderPath: string) => {
+  const dirContents = fs.readdirSync(folderPath);
+  return Promise.all(
+    dirContents.map(async contentPath => {
+      const singleChangesetPath = path.resolve(folderPath, contentPath);
+      try {
+        if ((await fs.readdir(singleChangesetPath)).length < 1) {
+          await fs.rmdir(singleChangesetPath);
+        }
+      } catch (err) {
+        if ((err as any).code !== "ENOTDIR") {
+          throw err;
+        }
+      }
+    })
+  );
+};
+
+export { removeEmptyFolders };
